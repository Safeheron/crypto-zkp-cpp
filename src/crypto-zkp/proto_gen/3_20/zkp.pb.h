// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zkp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_zkp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_zkp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "crypto-curve/proto_gen/curve_point.pb.switch.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_zkp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_zkp_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_zkp_2eproto;
namespace safeheron {
namespace proto {
class AliceRangeProof;
struct AliceRangeProofDefaultTypeInternal;
extern AliceRangeProofDefaultTypeInternal _AliceRangeProof_default_instance_;
class DLNProof;
struct DLNProofDefaultTypeInternal;
extern DLNProofDefaultTypeInternal _DLNProof_default_instance_;
class DLogProof;
struct DLogProofDefaultTypeInternal;
extern DLogProofDefaultTypeInternal _DLogProof_default_instance_;
class DLogProof_V2;
struct DLogProof_V2DefaultTypeInternal;
extern DLogProof_V2DefaultTypeInternal _DLogProof_V2_default_instance_;
class DlogElGamalComProof;
struct DlogElGamalComProofDefaultTypeInternal;
extern DlogElGamalComProofDefaultTypeInternal _DlogElGamalComProof_default_instance_;
class DlogEqualityProof;
struct DlogEqualityProofDefaultTypeInternal;
extern DlogEqualityProofDefaultTypeInternal _DlogEqualityProof_default_instance_;
class HEGProof_V2;
struct HEGProof_V2DefaultTypeInternal;
extern HEGProof_V2DefaultTypeInternal _HEGProof_V2_default_instance_;
class HEGProof_V3;
struct HEGProof_V3DefaultTypeInternal;
extern HEGProof_V3DefaultTypeInternal _HEGProof_V3_default_instance_;
class HegProof;
struct HegProofDefaultTypeInternal;
extern HegProofDefaultTypeInternal _HegProof_default_instance_;
class LinearCombinationProof;
struct LinearCombinationProofDefaultTypeInternal;
extern LinearCombinationProofDefaultTypeInternal _LinearCombinationProof_default_instance_;
class NoSmallFactorProof;
struct NoSmallFactorProofDefaultTypeInternal;
extern NoSmallFactorProofDefaultTypeInternal _NoSmallFactorProof_default_instance_;
class PailAffGroupEleRangeProof_V1;
struct PailAffGroupEleRangeProof_V1DefaultTypeInternal;
extern PailAffGroupEleRangeProof_V1DefaultTypeInternal _PailAffGroupEleRangeProof_V1_default_instance_;
class PailAffGroupEleRangeProof_V2;
struct PailAffGroupEleRangeProof_V2DefaultTypeInternal;
extern PailAffGroupEleRangeProof_V2DefaultTypeInternal _PailAffGroupEleRangeProof_V2_default_instance_;
class PailAffRangeProof;
struct PailAffRangeProofDefaultTypeInternal;
extern PailAffRangeProofDefaultTypeInternal _PailAffRangeProof_default_instance_;
class PailBlumModulusProof;
struct PailBlumModulusProofDefaultTypeInternal;
extern PailBlumModulusProofDefaultTypeInternal _PailBlumModulusProof_default_instance_;
class PailDecModuloProof;
struct PailDecModuloProofDefaultTypeInternal;
extern PailDecModuloProofDefaultTypeInternal _PailDecModuloProof_default_instance_;
class PailEncElGamalComRangeProof;
struct PailEncElGamalComRangeProofDefaultTypeInternal;
extern PailEncElGamalComRangeProofDefaultTypeInternal _PailEncElGamalComRangeProof_default_instance_;
class PailEncGroupEleRangeProof;
struct PailEncGroupEleRangeProofDefaultTypeInternal;
extern PailEncGroupEleRangeProofDefaultTypeInternal _PailEncGroupEleRangeProof_default_instance_;
class PailEncMulProof;
struct PailEncMulProofDefaultTypeInternal;
extern PailEncMulProofDefaultTypeInternal _PailEncMulProof_default_instance_;
class PailEncRangeProof_V1;
struct PailEncRangeProof_V1DefaultTypeInternal;
extern PailEncRangeProof_V1DefaultTypeInternal _PailEncRangeProof_V1_default_instance_;
class PailEncRangeProof_V2;
struct PailEncRangeProof_V2DefaultTypeInternal;
extern PailEncRangeProof_V2DefaultTypeInternal _PailEncRangeProof_V2_default_instance_;
class PailEncRangeProof_V3;
struct PailEncRangeProof_V3DefaultTypeInternal;
extern PailEncRangeProof_V3DefaultTypeInternal _PailEncRangeProof_V3_default_instance_;
class PailEncRangeProof_V3_Z;
struct PailEncRangeProof_V3_ZDefaultTypeInternal;
extern PailEncRangeProof_V3_ZDefaultTypeInternal _PailEncRangeProof_V3_Z_default_instance_;
class PailMulGroupEleRangeProof;
struct PailMulGroupEleRangeProofDefaultTypeInternal;
extern PailMulGroupEleRangeProofDefaultTypeInternal _PailMulGroupEleRangeProof_default_instance_;
class PailNProof;
struct PailNProofDefaultTypeInternal;
extern PailNProofDefaultTypeInternal _PailNProof_default_instance_;
class PailProof;
struct PailProofDefaultTypeInternal;
extern PailProofDefaultTypeInternal _PailProof_default_instance_;
class PedersenProof;
struct PedersenProofDefaultTypeInternal;
extern PedersenProofDefaultTypeInternal _PedersenProof_default_instance_;
class RingPedersenParamPriv;
struct RingPedersenParamPrivDefaultTypeInternal;
extern RingPedersenParamPrivDefaultTypeInternal _RingPedersenParamPriv_default_instance_;
class RingPedersenParamPub;
struct RingPedersenParamPubDefaultTypeInternal;
extern RingPedersenParamPubDefaultTypeInternal _RingPedersenParamPub_default_instance_;
class TwoDLNProof;
struct TwoDLNProofDefaultTypeInternal;
extern TwoDLNProofDefaultTypeInternal _TwoDLNProof_default_instance_;
}  // namespace proto
}  // namespace safeheron
PROTOBUF_NAMESPACE_OPEN
template<> ::safeheron::proto::AliceRangeProof* Arena::CreateMaybeMessage<::safeheron::proto::AliceRangeProof>(Arena*);
template<> ::safeheron::proto::DLNProof* Arena::CreateMaybeMessage<::safeheron::proto::DLNProof>(Arena*);
template<> ::safeheron::proto::DLogProof* Arena::CreateMaybeMessage<::safeheron::proto::DLogProof>(Arena*);
template<> ::safeheron::proto::DLogProof_V2* Arena::CreateMaybeMessage<::safeheron::proto::DLogProof_V2>(Arena*);
template<> ::safeheron::proto::DlogElGamalComProof* Arena::CreateMaybeMessage<::safeheron::proto::DlogElGamalComProof>(Arena*);
template<> ::safeheron::proto::DlogEqualityProof* Arena::CreateMaybeMessage<::safeheron::proto::DlogEqualityProof>(Arena*);
template<> ::safeheron::proto::HEGProof_V2* Arena::CreateMaybeMessage<::safeheron::proto::HEGProof_V2>(Arena*);
template<> ::safeheron::proto::HEGProof_V3* Arena::CreateMaybeMessage<::safeheron::proto::HEGProof_V3>(Arena*);
template<> ::safeheron::proto::HegProof* Arena::CreateMaybeMessage<::safeheron::proto::HegProof>(Arena*);
template<> ::safeheron::proto::LinearCombinationProof* Arena::CreateMaybeMessage<::safeheron::proto::LinearCombinationProof>(Arena*);
template<> ::safeheron::proto::NoSmallFactorProof* Arena::CreateMaybeMessage<::safeheron::proto::NoSmallFactorProof>(Arena*);
template<> ::safeheron::proto::PailAffGroupEleRangeProof_V1* Arena::CreateMaybeMessage<::safeheron::proto::PailAffGroupEleRangeProof_V1>(Arena*);
template<> ::safeheron::proto::PailAffGroupEleRangeProof_V2* Arena::CreateMaybeMessage<::safeheron::proto::PailAffGroupEleRangeProof_V2>(Arena*);
template<> ::safeheron::proto::PailAffRangeProof* Arena::CreateMaybeMessage<::safeheron::proto::PailAffRangeProof>(Arena*);
template<> ::safeheron::proto::PailBlumModulusProof* Arena::CreateMaybeMessage<::safeheron::proto::PailBlumModulusProof>(Arena*);
template<> ::safeheron::proto::PailDecModuloProof* Arena::CreateMaybeMessage<::safeheron::proto::PailDecModuloProof>(Arena*);
template<> ::safeheron::proto::PailEncElGamalComRangeProof* Arena::CreateMaybeMessage<::safeheron::proto::PailEncElGamalComRangeProof>(Arena*);
template<> ::safeheron::proto::PailEncGroupEleRangeProof* Arena::CreateMaybeMessage<::safeheron::proto::PailEncGroupEleRangeProof>(Arena*);
template<> ::safeheron::proto::PailEncMulProof* Arena::CreateMaybeMessage<::safeheron::proto::PailEncMulProof>(Arena*);
template<> ::safeheron::proto::PailEncRangeProof_V1* Arena::CreateMaybeMessage<::safeheron::proto::PailEncRangeProof_V1>(Arena*);
template<> ::safeheron::proto::PailEncRangeProof_V2* Arena::CreateMaybeMessage<::safeheron::proto::PailEncRangeProof_V2>(Arena*);
template<> ::safeheron::proto::PailEncRangeProof_V3* Arena::CreateMaybeMessage<::safeheron::proto::PailEncRangeProof_V3>(Arena*);
template<> ::safeheron::proto::PailEncRangeProof_V3_Z* Arena::CreateMaybeMessage<::safeheron::proto::PailEncRangeProof_V3_Z>(Arena*);
template<> ::safeheron::proto::PailMulGroupEleRangeProof* Arena::CreateMaybeMessage<::safeheron::proto::PailMulGroupEleRangeProof>(Arena*);
template<> ::safeheron::proto::PailNProof* Arena::CreateMaybeMessage<::safeheron::proto::PailNProof>(Arena*);
template<> ::safeheron::proto::PailProof* Arena::CreateMaybeMessage<::safeheron::proto::PailProof>(Arena*);
template<> ::safeheron::proto::PedersenProof* Arena::CreateMaybeMessage<::safeheron::proto::PedersenProof>(Arena*);
template<> ::safeheron::proto::RingPedersenParamPriv* Arena::CreateMaybeMessage<::safeheron::proto::RingPedersenParamPriv>(Arena*);
template<> ::safeheron::proto::RingPedersenParamPub* Arena::CreateMaybeMessage<::safeheron::proto::RingPedersenParamPub>(Arena*);
template<> ::safeheron::proto::TwoDLNProof* Arena::CreateMaybeMessage<::safeheron::proto::TwoDLNProof>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safeheron {
namespace proto {

// ===================================================================

class DLogProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DLogProof) */ {
 public:
  inline DLogProof() : DLogProof(nullptr) {}
  ~DLogProof() override;
  explicit PROTOBUF_CONSTEXPR DLogProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DLogProof(const DLogProof& from);
  DLogProof(DLogProof&& from) noexcept
    : DLogProof() {
    *this = ::std::move(from);
  }

  inline DLogProof& operator=(const DLogProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLogProof& operator=(DLogProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DLogProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const DLogProof* internal_default_instance() {
    return reinterpret_cast<const DLogProof*>(
               &_DLogProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DLogProof& a, DLogProof& b) {
    a.Swap(&b);
  }
  inline void Swap(DLogProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLogProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DLogProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DLogProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DLogProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DLogProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLogProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DLogProof";
  }
  protected:
  explicit DLogProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResFieldNumber = 3,
    kPkFieldNumber = 1,
    kGRFieldNumber = 2,
  };
  // string res = 3;
  void clear_res();
  const std::string& res() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_res(ArgT0&& arg0, ArgT... args);
  std::string* mutable_res();
  PROTOBUF_NODISCARD std::string* release_res();
  void set_allocated_res(std::string* res);
  private:
  const std::string& _internal_res() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_res(const std::string& value);
  std::string* _internal_mutable_res();
  public:

  // .safeheron.proto.CurvePoint pk = 1;
  bool has_pk() const;
  private:
  bool _internal_has_pk() const;
  public:
  void clear_pk();
  const ::safeheron::proto::CurvePoint& pk() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_pk();
  ::safeheron::proto::CurvePoint* mutable_pk();
  void set_allocated_pk(::safeheron::proto::CurvePoint* pk);
  private:
  const ::safeheron::proto::CurvePoint& _internal_pk() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_pk();
  public:
  void unsafe_arena_set_allocated_pk(
      ::safeheron::proto::CurvePoint* pk);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_pk();

  // .safeheron.proto.CurvePoint g_r = 2;
  bool has_g_r() const;
  private:
  bool _internal_has_g_r() const;
  public:
  void clear_g_r();
  const ::safeheron::proto::CurvePoint& g_r() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_g_r();
  ::safeheron::proto::CurvePoint* mutable_g_r();
  void set_allocated_g_r(::safeheron::proto::CurvePoint* g_r);
  private:
  const ::safeheron::proto::CurvePoint& _internal_g_r() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_g_r();
  public:
  void unsafe_arena_set_allocated_g_r(
      ::safeheron::proto::CurvePoint* g_r);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_g_r();

  // @@protoc_insertion_point(class_scope:safeheron.proto.DLogProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr res_;
  ::safeheron::proto::CurvePoint* pk_;
  ::safeheron::proto::CurvePoint* g_r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class DLogProof_V2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DLogProof_V2) */ {
 public:
  inline DLogProof_V2() : DLogProof_V2(nullptr) {}
  ~DLogProof_V2() override;
  explicit PROTOBUF_CONSTEXPR DLogProof_V2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DLogProof_V2(const DLogProof_V2& from);
  DLogProof_V2(DLogProof_V2&& from) noexcept
    : DLogProof_V2() {
    *this = ::std::move(from);
  }

  inline DLogProof_V2& operator=(const DLogProof_V2& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLogProof_V2& operator=(DLogProof_V2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DLogProof_V2& default_instance() {
    return *internal_default_instance();
  }
  static inline const DLogProof_V2* internal_default_instance() {
    return reinterpret_cast<const DLogProof_V2*>(
               &_DLogProof_V2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DLogProof_V2& a, DLogProof_V2& b) {
    a.Swap(&b);
  }
  inline void Swap(DLogProof_V2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLogProof_V2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DLogProof_V2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DLogProof_V2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DLogProof_V2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DLogProof_V2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLogProof_V2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DLogProof_V2";
  }
  protected:
  explicit DLogProof_V2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 3,
    kAFieldNumber = 2,
  };
  // string z = 3;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // .safeheron.proto.CurvePoint A = 2;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  const ::safeheron::proto::CurvePoint& a() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_a();
  ::safeheron::proto::CurvePoint* mutable_a();
  void set_allocated_a(::safeheron::proto::CurvePoint* a);
  private:
  const ::safeheron::proto::CurvePoint& _internal_a() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::safeheron::proto::CurvePoint* a);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_a();

  // @@protoc_insertion_point(class_scope:safeheron.proto.DLogProof_V2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::safeheron::proto::CurvePoint* a_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class HegProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.HegProof) */ {
 public:
  inline HegProof() : HegProof(nullptr) {}
  ~HegProof() override;
  explicit PROTOBUF_CONSTEXPR HegProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HegProof(const HegProof& from);
  HegProof(HegProof&& from) noexcept
    : HegProof() {
    *this = ::std::move(from);
  }

  inline HegProof& operator=(const HegProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline HegProof& operator=(HegProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HegProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const HegProof* internal_default_instance() {
    return reinterpret_cast<const HegProof*>(
               &_HegProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HegProof& a, HegProof& b) {
    a.Swap(&b);
  }
  inline void Swap(HegProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HegProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HegProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HegProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HegProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HegProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HegProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.HegProof";
  }
  protected:
  explicit HegProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZ1FieldNumber = 3,
    kZ2FieldNumber = 4,
    kTFieldNumber = 1,
    kA3FieldNumber = 2,
  };
  // string z1 = 3;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 4;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // .safeheron.proto.CurvePoint T = 1;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  const ::safeheron::proto::CurvePoint& t() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_t();
  ::safeheron::proto::CurvePoint* mutable_t();
  void set_allocated_t(::safeheron::proto::CurvePoint* t);
  private:
  const ::safeheron::proto::CurvePoint& _internal_t() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::safeheron::proto::CurvePoint* t);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_t();

  // .safeheron.proto.CurvePoint A3 = 2;
  bool has_a3() const;
  private:
  bool _internal_has_a3() const;
  public:
  void clear_a3();
  const ::safeheron::proto::CurvePoint& a3() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_a3();
  ::safeheron::proto::CurvePoint* mutable_a3();
  void set_allocated_a3(::safeheron::proto::CurvePoint* a3);
  private:
  const ::safeheron::proto::CurvePoint& _internal_a3() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_a3();
  public:
  void unsafe_arena_set_allocated_a3(
      ::safeheron::proto::CurvePoint* a3);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_a3();

  // @@protoc_insertion_point(class_scope:safeheron.proto.HegProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::safeheron::proto::CurvePoint* t_;
  ::safeheron::proto::CurvePoint* a3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class HEGProof_V2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.HEGProof_V2) */ {
 public:
  inline HEGProof_V2() : HEGProof_V2(nullptr) {}
  ~HEGProof_V2() override;
  explicit PROTOBUF_CONSTEXPR HEGProof_V2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HEGProof_V2(const HEGProof_V2& from);
  HEGProof_V2(HEGProof_V2&& from) noexcept
    : HEGProof_V2() {
    *this = ::std::move(from);
  }

  inline HEGProof_V2& operator=(const HEGProof_V2& from) {
    CopyFrom(from);
    return *this;
  }
  inline HEGProof_V2& operator=(HEGProof_V2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HEGProof_V2& default_instance() {
    return *internal_default_instance();
  }
  static inline const HEGProof_V2* internal_default_instance() {
    return reinterpret_cast<const HEGProof_V2*>(
               &_HEGProof_V2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HEGProof_V2& a, HEGProof_V2& b) {
    a.Swap(&b);
  }
  inline void Swap(HEGProof_V2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HEGProof_V2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HEGProof_V2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HEGProof_V2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HEGProof_V2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HEGProof_V2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HEGProof_V2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.HEGProof_V2";
  }
  protected:
  explicit HEGProof_V2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 3,
    kUFieldNumber = 4,
    kAlphaFieldNumber = 1,
    kBetaFieldNumber = 2,
  };
  // string t = 3;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string u = 4;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // .safeheron.proto.CurvePoint Alpha = 1;
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  const ::safeheron::proto::CurvePoint& alpha() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_alpha();
  ::safeheron::proto::CurvePoint* mutable_alpha();
  void set_allocated_alpha(::safeheron::proto::CurvePoint* alpha);
  private:
  const ::safeheron::proto::CurvePoint& _internal_alpha() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_alpha();
  public:
  void unsafe_arena_set_allocated_alpha(
      ::safeheron::proto::CurvePoint* alpha);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_alpha();

  // .safeheron.proto.CurvePoint Beta = 2;
  bool has_beta() const;
  private:
  bool _internal_has_beta() const;
  public:
  void clear_beta();
  const ::safeheron::proto::CurvePoint& beta() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_beta();
  ::safeheron::proto::CurvePoint* mutable_beta();
  void set_allocated_beta(::safeheron::proto::CurvePoint* beta);
  private:
  const ::safeheron::proto::CurvePoint& _internal_beta() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_beta();
  public:
  void unsafe_arena_set_allocated_beta(
      ::safeheron::proto::CurvePoint* beta);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_beta();

  // @@protoc_insertion_point(class_scope:safeheron.proto.HEGProof_V2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::safeheron::proto::CurvePoint* alpha_;
  ::safeheron::proto::CurvePoint* beta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class LinearCombinationProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.LinearCombinationProof) */ {
 public:
  inline LinearCombinationProof() : LinearCombinationProof(nullptr) {}
  ~LinearCombinationProof() override;
  explicit PROTOBUF_CONSTEXPR LinearCombinationProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearCombinationProof(const LinearCombinationProof& from);
  LinearCombinationProof(LinearCombinationProof&& from) noexcept
    : LinearCombinationProof() {
    *this = ::std::move(from);
  }

  inline LinearCombinationProof& operator=(const LinearCombinationProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearCombinationProof& operator=(LinearCombinationProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearCombinationProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearCombinationProof* internal_default_instance() {
    return reinterpret_cast<const LinearCombinationProof*>(
               &_LinearCombinationProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LinearCombinationProof& a, LinearCombinationProof& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearCombinationProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearCombinationProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearCombinationProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearCombinationProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearCombinationProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearCombinationProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearCombinationProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.LinearCombinationProof";
  }
  protected:
  explicit LinearCombinationProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 3,
    kUFieldNumber = 4,
    kAlphaFieldNumber = 1,
  };
  // string t = 3;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string u = 4;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // .safeheron.proto.CurvePoint Alpha = 1;
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  const ::safeheron::proto::CurvePoint& alpha() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_alpha();
  ::safeheron::proto::CurvePoint* mutable_alpha();
  void set_allocated_alpha(::safeheron::proto::CurvePoint* alpha);
  private:
  const ::safeheron::proto::CurvePoint& _internal_alpha() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_alpha();
  public:
  void unsafe_arena_set_allocated_alpha(
      ::safeheron::proto::CurvePoint* alpha);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_alpha();

  // @@protoc_insertion_point(class_scope:safeheron.proto.LinearCombinationProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::safeheron::proto::CurvePoint* alpha_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class HEGProof_V3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.HEGProof_V3) */ {
 public:
  inline HEGProof_V3() : HEGProof_V3(nullptr) {}
  ~HEGProof_V3() override;
  explicit PROTOBUF_CONSTEXPR HEGProof_V3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HEGProof_V3(const HEGProof_V3& from);
  HEGProof_V3(HEGProof_V3&& from) noexcept
    : HEGProof_V3() {
    *this = ::std::move(from);
  }

  inline HEGProof_V3& operator=(const HEGProof_V3& from) {
    CopyFrom(from);
    return *this;
  }
  inline HEGProof_V3& operator=(HEGProof_V3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HEGProof_V3& default_instance() {
    return *internal_default_instance();
  }
  static inline const HEGProof_V3* internal_default_instance() {
    return reinterpret_cast<const HEGProof_V3*>(
               &_HEGProof_V3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HEGProof_V3& a, HEGProof_V3& b) {
    a.Swap(&b);
  }
  inline void Swap(HEGProof_V3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HEGProof_V3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HEGProof_V3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HEGProof_V3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HEGProof_V3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HEGProof_V3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HEGProof_V3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.HEGProof_V3";
  }
  protected:
  explicit HEGProof_V3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 3,
    kUFieldNumber = 4,
    kAlphaFieldNumber = 1,
    kBetaFieldNumber = 2,
  };
  // string t = 3;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string u = 4;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // .safeheron.proto.CurvePoint Alpha = 1;
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  const ::safeheron::proto::CurvePoint& alpha() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_alpha();
  ::safeheron::proto::CurvePoint* mutable_alpha();
  void set_allocated_alpha(::safeheron::proto::CurvePoint* alpha);
  private:
  const ::safeheron::proto::CurvePoint& _internal_alpha() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_alpha();
  public:
  void unsafe_arena_set_allocated_alpha(
      ::safeheron::proto::CurvePoint* alpha);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_alpha();

  // .safeheron.proto.CurvePoint Beta = 2;
  bool has_beta() const;
  private:
  bool _internal_has_beta() const;
  public:
  void clear_beta();
  const ::safeheron::proto::CurvePoint& beta() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_beta();
  ::safeheron::proto::CurvePoint* mutable_beta();
  void set_allocated_beta(::safeheron::proto::CurvePoint* beta);
  private:
  const ::safeheron::proto::CurvePoint& _internal_beta() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_beta();
  public:
  void unsafe_arena_set_allocated_beta(
      ::safeheron::proto::CurvePoint* beta);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_beta();

  // @@protoc_insertion_point(class_scope:safeheron.proto.HEGProof_V3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::safeheron::proto::CurvePoint* alpha_;
  ::safeheron::proto::CurvePoint* beta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailProof) */ {
 public:
  inline PailProof() : PailProof(nullptr) {}
  ~PailProof() override;
  explicit PROTOBUF_CONSTEXPR PailProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailProof(const PailProof& from);
  PailProof(PailProof&& from) noexcept
    : PailProof() {
    *this = ::std::move(from);
  }

  inline PailProof& operator=(const PailProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailProof& operator=(PailProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailProof* internal_default_instance() {
    return reinterpret_cast<const PailProof*>(
               &_PailProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PailProof& a, PailProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailProof";
  }
  protected:
  explicit PailProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYNArrFieldNumber = 1,
  };
  // repeated string y_N_arr = 1;
  int y_n_arr_size() const;
  private:
  int _internal_y_n_arr_size() const;
  public:
  void clear_y_n_arr();
  const std::string& y_n_arr(int index) const;
  std::string* mutable_y_n_arr(int index);
  void set_y_n_arr(int index, const std::string& value);
  void set_y_n_arr(int index, std::string&& value);
  void set_y_n_arr(int index, const char* value);
  void set_y_n_arr(int index, const char* value, size_t size);
  std::string* add_y_n_arr();
  void add_y_n_arr(const std::string& value);
  void add_y_n_arr(std::string&& value);
  void add_y_n_arr(const char* value);
  void add_y_n_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& y_n_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_y_n_arr();
  private:
  const std::string& _internal_y_n_arr(int index) const;
  std::string* _internal_add_y_n_arr();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> y_n_arr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailNProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailNProof) */ {
 public:
  inline PailNProof() : PailNProof(nullptr) {}
  ~PailNProof() override;
  explicit PROTOBUF_CONSTEXPR PailNProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailNProof(const PailNProof& from);
  PailNProof(PailNProof&& from) noexcept
    : PailNProof() {
    *this = ::std::move(from);
  }

  inline PailNProof& operator=(const PailNProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailNProof& operator=(PailNProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailNProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailNProof* internal_default_instance() {
    return reinterpret_cast<const PailNProof*>(
               &_PailNProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PailNProof& a, PailNProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailNProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailNProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailNProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailNProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailNProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailNProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailNProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailNProof";
  }
  protected:
  explicit PailNProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYNArrFieldNumber = 1,
  };
  // repeated string y_N_arr = 1;
  int y_n_arr_size() const;
  private:
  int _internal_y_n_arr_size() const;
  public:
  void clear_y_n_arr();
  const std::string& y_n_arr(int index) const;
  std::string* mutable_y_n_arr(int index);
  void set_y_n_arr(int index, const std::string& value);
  void set_y_n_arr(int index, std::string&& value);
  void set_y_n_arr(int index, const char* value);
  void set_y_n_arr(int index, const char* value, size_t size);
  std::string* add_y_n_arr();
  void add_y_n_arr(const std::string& value);
  void add_y_n_arr(std::string&& value);
  void add_y_n_arr(const char* value);
  void add_y_n_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& y_n_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_y_n_arr();
  private:
  const std::string& _internal_y_n_arr(int index) const;
  std::string* _internal_add_y_n_arr();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailNProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> y_n_arr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class AliceRangeProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.AliceRangeProof) */ {
 public:
  inline AliceRangeProof() : AliceRangeProof(nullptr) {}
  ~AliceRangeProof() override;
  explicit PROTOBUF_CONSTEXPR AliceRangeProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AliceRangeProof(const AliceRangeProof& from);
  AliceRangeProof(AliceRangeProof&& from) noexcept
    : AliceRangeProof() {
    *this = ::std::move(from);
  }

  inline AliceRangeProof& operator=(const AliceRangeProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline AliceRangeProof& operator=(AliceRangeProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AliceRangeProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const AliceRangeProof* internal_default_instance() {
    return reinterpret_cast<const AliceRangeProof*>(
               &_AliceRangeProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AliceRangeProof& a, AliceRangeProof& b) {
    a.Swap(&b);
  }
  inline void Swap(AliceRangeProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AliceRangeProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AliceRangeProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AliceRangeProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AliceRangeProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AliceRangeProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AliceRangeProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.AliceRangeProof";
  }
  protected:
  explicit AliceRangeProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 1,
    kUFieldNumber = 2,
    kWFieldNumber = 3,
    kSFieldNumber = 4,
    kS1FieldNumber = 5,
    kS2FieldNumber = 6,
  };
  // string z = 1;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string u = 2;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // string w = 3;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string s = 4;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string s1 = 5;
  void clear_s1();
  const std::string& s1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // string s2 = 6;
  void clear_s2();
  const std::string& s2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.AliceRangeProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class RingPedersenParamPub final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RingPedersenParamPub) */ {
 public:
  inline RingPedersenParamPub() : RingPedersenParamPub(nullptr) {}
  ~RingPedersenParamPub() override;
  explicit PROTOBUF_CONSTEXPR RingPedersenParamPub(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RingPedersenParamPub(const RingPedersenParamPub& from);
  RingPedersenParamPub(RingPedersenParamPub&& from) noexcept
    : RingPedersenParamPub() {
    *this = ::std::move(from);
  }

  inline RingPedersenParamPub& operator=(const RingPedersenParamPub& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingPedersenParamPub& operator=(RingPedersenParamPub&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RingPedersenParamPub& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingPedersenParamPub* internal_default_instance() {
    return reinterpret_cast<const RingPedersenParamPub*>(
               &_RingPedersenParamPub_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RingPedersenParamPub& a, RingPedersenParamPub& b) {
    a.Swap(&b);
  }
  inline void Swap(RingPedersenParamPub* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingPedersenParamPub* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingPedersenParamPub* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingPedersenParamPub>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RingPedersenParamPub& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RingPedersenParamPub& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RingPedersenParamPub* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RingPedersenParamPub";
  }
  protected:
  explicit RingPedersenParamPub(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNTildeFieldNumber = 1,
    kH1FieldNumber = 2,
    kH2FieldNumber = 3,
  };
  // string N_tilde = 1;
  void clear_n_tilde();
  const std::string& n_tilde() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_n_tilde(ArgT0&& arg0, ArgT... args);
  std::string* mutable_n_tilde();
  PROTOBUF_NODISCARD std::string* release_n_tilde();
  void set_allocated_n_tilde(std::string* n_tilde);
  private:
  const std::string& _internal_n_tilde() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_n_tilde(const std::string& value);
  std::string* _internal_mutable_n_tilde();
  public:

  // string h1 = 2;
  void clear_h1();
  const std::string& h1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_h1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_h1();
  PROTOBUF_NODISCARD std::string* release_h1();
  void set_allocated_h1(std::string* h1);
  private:
  const std::string& _internal_h1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_h1(const std::string& value);
  std::string* _internal_mutable_h1();
  public:

  // string h2 = 3;
  void clear_h2();
  const std::string& h2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_h2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_h2();
  PROTOBUF_NODISCARD std::string* release_h2();
  void set_allocated_h2(std::string* h2);
  private:
  const std::string& _internal_h2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_h2(const std::string& value);
  std::string* _internal_mutable_h2();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RingPedersenParamPub)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr n_tilde_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr h1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr h2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class RingPedersenParamPriv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RingPedersenParamPriv) */ {
 public:
  inline RingPedersenParamPriv() : RingPedersenParamPriv(nullptr) {}
  ~RingPedersenParamPriv() override;
  explicit PROTOBUF_CONSTEXPR RingPedersenParamPriv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RingPedersenParamPriv(const RingPedersenParamPriv& from);
  RingPedersenParamPriv(RingPedersenParamPriv&& from) noexcept
    : RingPedersenParamPriv() {
    *this = ::std::move(from);
  }

  inline RingPedersenParamPriv& operator=(const RingPedersenParamPriv& from) {
    CopyFrom(from);
    return *this;
  }
  inline RingPedersenParamPriv& operator=(RingPedersenParamPriv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RingPedersenParamPriv& default_instance() {
    return *internal_default_instance();
  }
  static inline const RingPedersenParamPriv* internal_default_instance() {
    return reinterpret_cast<const RingPedersenParamPriv*>(
               &_RingPedersenParamPriv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RingPedersenParamPriv& a, RingPedersenParamPriv& b) {
    a.Swap(&b);
  }
  inline void Swap(RingPedersenParamPriv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RingPedersenParamPriv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RingPedersenParamPriv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RingPedersenParamPriv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RingPedersenParamPriv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RingPedersenParamPriv& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RingPedersenParamPriv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.RingPedersenParamPriv";
  }
  protected:
  explicit RingPedersenParamPriv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNTildeFieldNumber = 1,
    kPFieldNumber = 2,
    kQFieldNumber = 3,
    kH1FieldNumber = 4,
    kH2FieldNumber = 5,
    kAlphaFieldNumber = 6,
    kBetaFieldNumber = 7,
  };
  // string N_tilde = 1;
  void clear_n_tilde();
  const std::string& n_tilde() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_n_tilde(ArgT0&& arg0, ArgT... args);
  std::string* mutable_n_tilde();
  PROTOBUF_NODISCARD std::string* release_n_tilde();
  void set_allocated_n_tilde(std::string* n_tilde);
  private:
  const std::string& _internal_n_tilde() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_n_tilde(const std::string& value);
  std::string* _internal_mutable_n_tilde();
  public:

  // string p = 2;
  void clear_p();
  const std::string& p() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p();
  PROTOBUF_NODISCARD std::string* release_p();
  void set_allocated_p(std::string* p);
  private:
  const std::string& _internal_p() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p(const std::string& value);
  std::string* _internal_mutable_p();
  public:

  // string q = 3;
  void clear_q();
  const std::string& q() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_q(ArgT0&& arg0, ArgT... args);
  std::string* mutable_q();
  PROTOBUF_NODISCARD std::string* release_q();
  void set_allocated_q(std::string* q);
  private:
  const std::string& _internal_q() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_q(const std::string& value);
  std::string* _internal_mutable_q();
  public:

  // string h1 = 4;
  void clear_h1();
  const std::string& h1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_h1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_h1();
  PROTOBUF_NODISCARD std::string* release_h1();
  void set_allocated_h1(std::string* h1);
  private:
  const std::string& _internal_h1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_h1(const std::string& value);
  std::string* _internal_mutable_h1();
  public:

  // string h2 = 5;
  void clear_h2();
  const std::string& h2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_h2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_h2();
  PROTOBUF_NODISCARD std::string* release_h2();
  void set_allocated_h2(std::string* h2);
  private:
  const std::string& _internal_h2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_h2(const std::string& value);
  std::string* _internal_mutable_h2();
  public:

  // string alpha = 6;
  void clear_alpha();
  const std::string& alpha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alpha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alpha();
  PROTOBUF_NODISCARD std::string* release_alpha();
  void set_allocated_alpha(std::string* alpha);
  private:
  const std::string& _internal_alpha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alpha(const std::string& value);
  std::string* _internal_mutable_alpha();
  public:

  // string beta = 7;
  void clear_beta();
  const std::string& beta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_beta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_beta();
  PROTOBUF_NODISCARD std::string* release_beta();
  void set_allocated_beta(std::string* beta);
  private:
  const std::string& _internal_beta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_beta(const std::string& value);
  std::string* _internal_mutable_beta();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.RingPedersenParamPriv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr n_tilde_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr q_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr h1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr h2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alpha_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr beta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class DLNProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DLNProof) */ {
 public:
  inline DLNProof() : DLNProof(nullptr) {}
  ~DLNProof() override;
  explicit PROTOBUF_CONSTEXPR DLNProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DLNProof(const DLNProof& from);
  DLNProof(DLNProof&& from) noexcept
    : DLNProof() {
    *this = ::std::move(from);
  }

  inline DLNProof& operator=(const DLNProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline DLNProof& operator=(DLNProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DLNProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const DLNProof* internal_default_instance() {
    return reinterpret_cast<const DLNProof*>(
               &_DLNProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DLNProof& a, DLNProof& b) {
    a.Swap(&b);
  }
  inline void Swap(DLNProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DLNProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DLNProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DLNProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DLNProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DLNProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DLNProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DLNProof";
  }
  protected:
  explicit DLNProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaArrFieldNumber = 1,
    kTArrFieldNumber = 2,
  };
  // repeated string alpha_arr = 1;
  int alpha_arr_size() const;
  private:
  int _internal_alpha_arr_size() const;
  public:
  void clear_alpha_arr();
  const std::string& alpha_arr(int index) const;
  std::string* mutable_alpha_arr(int index);
  void set_alpha_arr(int index, const std::string& value);
  void set_alpha_arr(int index, std::string&& value);
  void set_alpha_arr(int index, const char* value);
  void set_alpha_arr(int index, const char* value, size_t size);
  std::string* add_alpha_arr();
  void add_alpha_arr(const std::string& value);
  void add_alpha_arr(std::string&& value);
  void add_alpha_arr(const char* value);
  void add_alpha_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& alpha_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_alpha_arr();
  private:
  const std::string& _internal_alpha_arr(int index) const;
  std::string* _internal_add_alpha_arr();
  public:

  // repeated string t_arr = 2;
  int t_arr_size() const;
  private:
  int _internal_t_arr_size() const;
  public:
  void clear_t_arr();
  const std::string& t_arr(int index) const;
  std::string* mutable_t_arr(int index);
  void set_t_arr(int index, const std::string& value);
  void set_t_arr(int index, std::string&& value);
  void set_t_arr(int index, const char* value);
  void set_t_arr(int index, const char* value, size_t size);
  std::string* add_t_arr();
  void add_t_arr(const std::string& value);
  void add_t_arr(std::string&& value);
  void add_t_arr(const char* value);
  void add_t_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& t_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_t_arr();
  private:
  const std::string& _internal_t_arr(int index) const;
  std::string* _internal_add_t_arr();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.DLNProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> alpha_arr_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> t_arr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class TwoDLNProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.TwoDLNProof) */ {
 public:
  inline TwoDLNProof() : TwoDLNProof(nullptr) {}
  ~TwoDLNProof() override;
  explicit PROTOBUF_CONSTEXPR TwoDLNProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TwoDLNProof(const TwoDLNProof& from);
  TwoDLNProof(TwoDLNProof&& from) noexcept
    : TwoDLNProof() {
    *this = ::std::move(from);
  }

  inline TwoDLNProof& operator=(const TwoDLNProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline TwoDLNProof& operator=(TwoDLNProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TwoDLNProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const TwoDLNProof* internal_default_instance() {
    return reinterpret_cast<const TwoDLNProof*>(
               &_TwoDLNProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TwoDLNProof& a, TwoDLNProof& b) {
    a.Swap(&b);
  }
  inline void Swap(TwoDLNProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TwoDLNProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TwoDLNProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TwoDLNProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TwoDLNProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TwoDLNProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TwoDLNProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.TwoDLNProof";
  }
  protected:
  explicit TwoDLNProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlnProof1FieldNumber = 1,
    kDlnProof2FieldNumber = 2,
  };
  // .safeheron.proto.DLNProof dln_proof_1 = 1;
  bool has_dln_proof_1() const;
  private:
  bool _internal_has_dln_proof_1() const;
  public:
  void clear_dln_proof_1();
  const ::safeheron::proto::DLNProof& dln_proof_1() const;
  PROTOBUF_NODISCARD ::safeheron::proto::DLNProof* release_dln_proof_1();
  ::safeheron::proto::DLNProof* mutable_dln_proof_1();
  void set_allocated_dln_proof_1(::safeheron::proto::DLNProof* dln_proof_1);
  private:
  const ::safeheron::proto::DLNProof& _internal_dln_proof_1() const;
  ::safeheron::proto::DLNProof* _internal_mutable_dln_proof_1();
  public:
  void unsafe_arena_set_allocated_dln_proof_1(
      ::safeheron::proto::DLNProof* dln_proof_1);
  ::safeheron::proto::DLNProof* unsafe_arena_release_dln_proof_1();

  // .safeheron.proto.DLNProof dln_proof_2 = 2;
  bool has_dln_proof_2() const;
  private:
  bool _internal_has_dln_proof_2() const;
  public:
  void clear_dln_proof_2();
  const ::safeheron::proto::DLNProof& dln_proof_2() const;
  PROTOBUF_NODISCARD ::safeheron::proto::DLNProof* release_dln_proof_2();
  ::safeheron::proto::DLNProof* mutable_dln_proof_2();
  void set_allocated_dln_proof_2(::safeheron::proto::DLNProof* dln_proof_2);
  private:
  const ::safeheron::proto::DLNProof& _internal_dln_proof_2() const;
  ::safeheron::proto::DLNProof* _internal_mutable_dln_proof_2();
  public:
  void unsafe_arena_set_allocated_dln_proof_2(
      ::safeheron::proto::DLNProof* dln_proof_2);
  ::safeheron::proto::DLNProof* unsafe_arena_release_dln_proof_2();

  // @@protoc_insertion_point(class_scope:safeheron.proto.TwoDLNProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::safeheron::proto::DLNProof* dln_proof_1_;
  ::safeheron::proto::DLNProof* dln_proof_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PedersenProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PedersenProof) */ {
 public:
  inline PedersenProof() : PedersenProof(nullptr) {}
  ~PedersenProof() override;
  explicit PROTOBUF_CONSTEXPR PedersenProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PedersenProof(const PedersenProof& from);
  PedersenProof(PedersenProof&& from) noexcept
    : PedersenProof() {
    *this = ::std::move(from);
  }

  inline PedersenProof& operator=(const PedersenProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PedersenProof& operator=(PedersenProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PedersenProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PedersenProof* internal_default_instance() {
    return reinterpret_cast<const PedersenProof*>(
               &_PedersenProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PedersenProof& a, PedersenProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PedersenProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PedersenProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PedersenProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PedersenProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PedersenProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PedersenProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PedersenProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PedersenProof";
  }
  protected:
  explicit PedersenProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTFieldNumber = 4,
    kUFieldNumber = 5,
    kAlphaFieldNumber = 3,
  };
  // string t = 4;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string u = 5;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // .safeheron.proto.CurvePoint Alpha = 3;
  bool has_alpha() const;
  private:
  bool _internal_has_alpha() const;
  public:
  void clear_alpha();
  const ::safeheron::proto::CurvePoint& alpha() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_alpha();
  ::safeheron::proto::CurvePoint* mutable_alpha();
  void set_allocated_alpha(::safeheron::proto::CurvePoint* alpha);
  private:
  const ::safeheron::proto::CurvePoint& _internal_alpha() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_alpha();
  public:
  void unsafe_arena_set_allocated_alpha(
      ::safeheron::proto::CurvePoint* alpha);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_alpha();

  // @@protoc_insertion_point(class_scope:safeheron.proto.PedersenProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::safeheron::proto::CurvePoint* alpha_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncRangeProof_V3_Z final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncRangeProof_V3.Z) */ {
 public:
  inline PailEncRangeProof_V3_Z() : PailEncRangeProof_V3_Z(nullptr) {}
  ~PailEncRangeProof_V3_Z() override;
  explicit PROTOBUF_CONSTEXPR PailEncRangeProof_V3_Z(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncRangeProof_V3_Z(const PailEncRangeProof_V3_Z& from);
  PailEncRangeProof_V3_Z(PailEncRangeProof_V3_Z&& from) noexcept
    : PailEncRangeProof_V3_Z() {
    *this = ::std::move(from);
  }

  inline PailEncRangeProof_V3_Z& operator=(const PailEncRangeProof_V3_Z& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncRangeProof_V3_Z& operator=(PailEncRangeProof_V3_Z&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncRangeProof_V3_Z& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncRangeProof_V3_Z* internal_default_instance() {
    return reinterpret_cast<const PailEncRangeProof_V3_Z*>(
               &_PailEncRangeProof_V3_Z_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PailEncRangeProof_V3_Z& a, PailEncRangeProof_V3_Z& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncRangeProof_V3_Z* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncRangeProof_V3_Z* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncRangeProof_V3_Z* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncRangeProof_V3_Z>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncRangeProof_V3_Z& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncRangeProof_V3_Z& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncRangeProof_V3_Z* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncRangeProof_V3.Z";
  }
  protected:
  explicit PailEncRangeProof_V3_Z(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaskedXFieldNumber = 2,
    kMaskedRFieldNumber = 3,
    kW1FieldNumber = 4,
    kW2FieldNumber = 5,
    kR1FieldNumber = 6,
    kR2FieldNumber = 7,
    kJFieldNumber = 1,
  };
  // string masked_x = 2;
  void clear_masked_x();
  const std::string& masked_x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_masked_x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_masked_x();
  PROTOBUF_NODISCARD std::string* release_masked_x();
  void set_allocated_masked_x(std::string* masked_x);
  private:
  const std::string& _internal_masked_x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_masked_x(const std::string& value);
  std::string* _internal_mutable_masked_x();
  public:

  // string masked_r = 3;
  void clear_masked_r();
  const std::string& masked_r() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_masked_r(ArgT0&& arg0, ArgT... args);
  std::string* mutable_masked_r();
  PROTOBUF_NODISCARD std::string* release_masked_r();
  void set_allocated_masked_r(std::string* masked_r);
  private:
  const std::string& _internal_masked_r() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_masked_r(const std::string& value);
  std::string* _internal_mutable_masked_r();
  public:

  // string w1 = 4;
  void clear_w1();
  const std::string& w1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w1();
  PROTOBUF_NODISCARD std::string* release_w1();
  void set_allocated_w1(std::string* w1);
  private:
  const std::string& _internal_w1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w1(const std::string& value);
  std::string* _internal_mutable_w1();
  public:

  // string w2 = 5;
  void clear_w2();
  const std::string& w2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w2();
  PROTOBUF_NODISCARD std::string* release_w2();
  void set_allocated_w2(std::string* w2);
  private:
  const std::string& _internal_w2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w2(const std::string& value);
  std::string* _internal_mutable_w2();
  public:

  // string r1 = 6;
  void clear_r1();
  const std::string& r1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_r1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_r1();
  PROTOBUF_NODISCARD std::string* release_r1();
  void set_allocated_r1(std::string* r1);
  private:
  const std::string& _internal_r1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_r1(const std::string& value);
  std::string* _internal_mutable_r1();
  public:

  // string r2 = 7;
  void clear_r2();
  const std::string& r2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_r2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_r2();
  PROTOBUF_NODISCARD std::string* release_r2();
  void set_allocated_r2(std::string* r2);
  private:
  const std::string& _internal_r2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_r2(const std::string& value);
  std::string* _internal_mutable_r2();
  public:

  // int32 j = 1;
  void clear_j();
  int32_t j() const;
  void set_j(int32_t value);
  private:
  int32_t _internal_j() const;
  void _internal_set_j(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncRangeProof_V3.Z)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr masked_x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr masked_r_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr r1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr r2_;
  int32_t j_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncRangeProof_V3 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncRangeProof_V3) */ {
 public:
  inline PailEncRangeProof_V3() : PailEncRangeProof_V3(nullptr) {}
  ~PailEncRangeProof_V3() override;
  explicit PROTOBUF_CONSTEXPR PailEncRangeProof_V3(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncRangeProof_V3(const PailEncRangeProof_V3& from);
  PailEncRangeProof_V3(PailEncRangeProof_V3&& from) noexcept
    : PailEncRangeProof_V3() {
    *this = ::std::move(from);
  }

  inline PailEncRangeProof_V3& operator=(const PailEncRangeProof_V3& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncRangeProof_V3& operator=(PailEncRangeProof_V3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncRangeProof_V3& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncRangeProof_V3* internal_default_instance() {
    return reinterpret_cast<const PailEncRangeProof_V3*>(
               &_PailEncRangeProof_V3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PailEncRangeProof_V3& a, PailEncRangeProof_V3& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncRangeProof_V3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncRangeProof_V3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncRangeProof_V3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncRangeProof_V3>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncRangeProof_V3& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncRangeProof_V3& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncRangeProof_V3* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncRangeProof_V3";
  }
  protected:
  explicit PailEncRangeProof_V3(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PailEncRangeProof_V3_Z Z;

  // accessors -------------------------------------------------------

  enum : int {
    kC1ArrFieldNumber = 1,
    kC2ArrFieldNumber = 2,
    kZArrFieldNumber = 3,
  };
  // repeated string c1_arr = 1;
  int c1_arr_size() const;
  private:
  int _internal_c1_arr_size() const;
  public:
  void clear_c1_arr();
  const std::string& c1_arr(int index) const;
  std::string* mutable_c1_arr(int index);
  void set_c1_arr(int index, const std::string& value);
  void set_c1_arr(int index, std::string&& value);
  void set_c1_arr(int index, const char* value);
  void set_c1_arr(int index, const char* value, size_t size);
  std::string* add_c1_arr();
  void add_c1_arr(const std::string& value);
  void add_c1_arr(std::string&& value);
  void add_c1_arr(const char* value);
  void add_c1_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& c1_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_c1_arr();
  private:
  const std::string& _internal_c1_arr(int index) const;
  std::string* _internal_add_c1_arr();
  public:

  // repeated string c2_arr = 2;
  int c2_arr_size() const;
  private:
  int _internal_c2_arr_size() const;
  public:
  void clear_c2_arr();
  const std::string& c2_arr(int index) const;
  std::string* mutable_c2_arr(int index);
  void set_c2_arr(int index, const std::string& value);
  void set_c2_arr(int index, std::string&& value);
  void set_c2_arr(int index, const char* value);
  void set_c2_arr(int index, const char* value, size_t size);
  std::string* add_c2_arr();
  void add_c2_arr(const std::string& value);
  void add_c2_arr(std::string&& value);
  void add_c2_arr(const char* value);
  void add_c2_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& c2_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_c2_arr();
  private:
  const std::string& _internal_c2_arr(int index) const;
  std::string* _internal_add_c2_arr();
  public:

  // repeated .safeheron.proto.PailEncRangeProof_V3.Z z_arr = 3;
  int z_arr_size() const;
  private:
  int _internal_z_arr_size() const;
  public:
  void clear_z_arr();
  ::safeheron::proto::PailEncRangeProof_V3_Z* mutable_z_arr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safeheron::proto::PailEncRangeProof_V3_Z >*
      mutable_z_arr();
  private:
  const ::safeheron::proto::PailEncRangeProof_V3_Z& _internal_z_arr(int index) const;
  ::safeheron::proto::PailEncRangeProof_V3_Z* _internal_add_z_arr();
  public:
  const ::safeheron::proto::PailEncRangeProof_V3_Z& z_arr(int index) const;
  ::safeheron::proto::PailEncRangeProof_V3_Z* add_z_arr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safeheron::proto::PailEncRangeProof_V3_Z >&
      z_arr() const;

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncRangeProof_V3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> c1_arr_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> c2_arr_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safeheron::proto::PailEncRangeProof_V3_Z > z_arr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncRangeProof_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncRangeProof_V1) */ {
 public:
  inline PailEncRangeProof_V1() : PailEncRangeProof_V1(nullptr) {}
  ~PailEncRangeProof_V1() override;
  explicit PROTOBUF_CONSTEXPR PailEncRangeProof_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncRangeProof_V1(const PailEncRangeProof_V1& from);
  PailEncRangeProof_V1(PailEncRangeProof_V1&& from) noexcept
    : PailEncRangeProof_V1() {
    *this = ::std::move(from);
  }

  inline PailEncRangeProof_V1& operator=(const PailEncRangeProof_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncRangeProof_V1& operator=(PailEncRangeProof_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncRangeProof_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncRangeProof_V1* internal_default_instance() {
    return reinterpret_cast<const PailEncRangeProof_V1*>(
               &_PailEncRangeProof_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PailEncRangeProof_V1& a, PailEncRangeProof_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncRangeProof_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncRangeProof_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncRangeProof_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncRangeProof_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncRangeProof_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncRangeProof_V1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncRangeProof_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncRangeProof_V1";
  }
  protected:
  explicit PailEncRangeProof_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 1,
    kUFieldNumber = 2,
    kWFieldNumber = 3,
    kSFieldNumber = 4,
    kS1FieldNumber = 5,
    kS2FieldNumber = 6,
  };
  // string z = 1;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string u = 2;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // string w = 3;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string s = 4;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string s1 = 5;
  void clear_s1();
  const std::string& s1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // string s2 = 6;
  void clear_s2();
  const std::string& s2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncRangeProof_V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncRangeProof_V2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncRangeProof_V2) */ {
 public:
  inline PailEncRangeProof_V2() : PailEncRangeProof_V2(nullptr) {}
  ~PailEncRangeProof_V2() override;
  explicit PROTOBUF_CONSTEXPR PailEncRangeProof_V2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncRangeProof_V2(const PailEncRangeProof_V2& from);
  PailEncRangeProof_V2(PailEncRangeProof_V2&& from) noexcept
    : PailEncRangeProof_V2() {
    *this = ::std::move(from);
  }

  inline PailEncRangeProof_V2& operator=(const PailEncRangeProof_V2& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncRangeProof_V2& operator=(PailEncRangeProof_V2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncRangeProof_V2& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncRangeProof_V2* internal_default_instance() {
    return reinterpret_cast<const PailEncRangeProof_V2*>(
               &_PailEncRangeProof_V2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PailEncRangeProof_V2& a, PailEncRangeProof_V2& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncRangeProof_V2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncRangeProof_V2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncRangeProof_V2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncRangeProof_V2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncRangeProof_V2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncRangeProof_V2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncRangeProof_V2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncRangeProof_V2";
  }
  protected:
  explicit PailEncRangeProof_V2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kAFieldNumber = 2,
    kCFieldNumber = 3,
    kZ1FieldNumber = 4,
    kZ2FieldNumber = 5,
    kZ3FieldNumber = 6,
  };
  // string S = 1;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string A = 2;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string C = 3;
  void clear_c();
  const std::string& c() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_c(ArgT0&& arg0, ArgT... args);
  std::string* mutable_c();
  PROTOBUF_NODISCARD std::string* release_c();
  void set_allocated_c(std::string* c);
  private:
  const std::string& _internal_c() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_c(const std::string& value);
  std::string* _internal_mutable_c();
  public:

  // string z1 = 4;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 5;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string z3 = 6;
  void clear_z3();
  const std::string& z3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z3();
  PROTOBUF_NODISCARD std::string* release_z3();
  void set_allocated_z3(std::string* z3);
  private:
  const std::string& _internal_z3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z3(const std::string& value);
  std::string* _internal_mutable_z3();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncRangeProof_V2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr c_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z3_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncGroupEleRangeProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncGroupEleRangeProof) */ {
 public:
  inline PailEncGroupEleRangeProof() : PailEncGroupEleRangeProof(nullptr) {}
  ~PailEncGroupEleRangeProof() override;
  explicit PROTOBUF_CONSTEXPR PailEncGroupEleRangeProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncGroupEleRangeProof(const PailEncGroupEleRangeProof& from);
  PailEncGroupEleRangeProof(PailEncGroupEleRangeProof&& from) noexcept
    : PailEncGroupEleRangeProof() {
    *this = ::std::move(from);
  }

  inline PailEncGroupEleRangeProof& operator=(const PailEncGroupEleRangeProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncGroupEleRangeProof& operator=(PailEncGroupEleRangeProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncGroupEleRangeProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncGroupEleRangeProof* internal_default_instance() {
    return reinterpret_cast<const PailEncGroupEleRangeProof*>(
               &_PailEncGroupEleRangeProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PailEncGroupEleRangeProof& a, PailEncGroupEleRangeProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncGroupEleRangeProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncGroupEleRangeProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncGroupEleRangeProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncGroupEleRangeProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncGroupEleRangeProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncGroupEleRangeProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncGroupEleRangeProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncGroupEleRangeProof";
  }
  protected:
  explicit PailEncGroupEleRangeProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kAFieldNumber = 2,
    kDFieldNumber = 4,
    kZ1FieldNumber = 5,
    kZ2FieldNumber = 6,
    kZ3FieldNumber = 7,
    kYFieldNumber = 3,
  };
  // string S = 1;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string A = 2;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string D = 4;
  void clear_d();
  const std::string& d() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_d(ArgT0&& arg0, ArgT... args);
  std::string* mutable_d();
  PROTOBUF_NODISCARD std::string* release_d();
  void set_allocated_d(std::string* d);
  private:
  const std::string& _internal_d() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_d(const std::string& value);
  std::string* _internal_mutable_d();
  public:

  // string z1 = 5;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 6;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string z3 = 7;
  void clear_z3();
  const std::string& z3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z3();
  PROTOBUF_NODISCARD std::string* release_z3();
  void set_allocated_z3(std::string* z3);
  private:
  const std::string& _internal_z3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z3(const std::string& value);
  std::string* _internal_mutable_z3();
  public:

  // .safeheron.proto.CurvePoint Y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::safeheron::proto::CurvePoint& y() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_y();
  ::safeheron::proto::CurvePoint* mutable_y();
  void set_allocated_y(::safeheron::proto::CurvePoint* y);
  private:
  const ::safeheron::proto::CurvePoint& _internal_y() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::safeheron::proto::CurvePoint* y);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_y();

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncGroupEleRangeProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr d_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z3_;
  ::safeheron::proto::CurvePoint* y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailAffRangeProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailAffRangeProof) */ {
 public:
  inline PailAffRangeProof() : PailAffRangeProof(nullptr) {}
  ~PailAffRangeProof() override;
  explicit PROTOBUF_CONSTEXPR PailAffRangeProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailAffRangeProof(const PailAffRangeProof& from);
  PailAffRangeProof(PailAffRangeProof&& from) noexcept
    : PailAffRangeProof() {
    *this = ::std::move(from);
  }

  inline PailAffRangeProof& operator=(const PailAffRangeProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailAffRangeProof& operator=(PailAffRangeProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailAffRangeProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailAffRangeProof* internal_default_instance() {
    return reinterpret_cast<const PailAffRangeProof*>(
               &_PailAffRangeProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PailAffRangeProof& a, PailAffRangeProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailAffRangeProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailAffRangeProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailAffRangeProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailAffRangeProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailAffRangeProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailAffRangeProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailAffRangeProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailAffRangeProof";
  }
  protected:
  explicit PailAffRangeProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 2,
    kZPrimeFieldNumber = 3,
    kTFieldNumber = 4,
    kVFieldNumber = 5,
    kWFieldNumber = 6,
    kSFieldNumber = 7,
    kS1FieldNumber = 8,
    kS2FieldNumber = 9,
    kT1FieldNumber = 10,
    kT2FieldNumber = 11,
  };
  // string z = 2;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string z_prime = 3;
  void clear_z_prime();
  const std::string& z_prime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z_prime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z_prime();
  PROTOBUF_NODISCARD std::string* release_z_prime();
  void set_allocated_z_prime(std::string* z_prime);
  private:
  const std::string& _internal_z_prime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z_prime(const std::string& value);
  std::string* _internal_mutable_z_prime();
  public:

  // string t = 4;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string v = 5;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // string w = 6;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string s = 7;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string s1 = 8;
  void clear_s1();
  const std::string& s1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // string s2 = 9;
  void clear_s2();
  const std::string& s2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // string t1 = 10;
  void clear_t1();
  const std::string& t1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t1();
  PROTOBUF_NODISCARD std::string* release_t1();
  void set_allocated_t1(std::string* t1);
  private:
  const std::string& _internal_t1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t1(const std::string& value);
  std::string* _internal_mutable_t1();
  public:

  // string t2 = 11;
  void clear_t2();
  const std::string& t2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t2();
  PROTOBUF_NODISCARD std::string* release_t2();
  void set_allocated_t2(std::string* t2);
  private:
  const std::string& _internal_t2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t2(const std::string& value);
  std::string* _internal_mutable_t2();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailAffRangeProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_prime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailAffGroupEleRangeProof_V1 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailAffGroupEleRangeProof_V1) */ {
 public:
  inline PailAffGroupEleRangeProof_V1() : PailAffGroupEleRangeProof_V1(nullptr) {}
  ~PailAffGroupEleRangeProof_V1() override;
  explicit PROTOBUF_CONSTEXPR PailAffGroupEleRangeProof_V1(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailAffGroupEleRangeProof_V1(const PailAffGroupEleRangeProof_V1& from);
  PailAffGroupEleRangeProof_V1(PailAffGroupEleRangeProof_V1&& from) noexcept
    : PailAffGroupEleRangeProof_V1() {
    *this = ::std::move(from);
  }

  inline PailAffGroupEleRangeProof_V1& operator=(const PailAffGroupEleRangeProof_V1& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailAffGroupEleRangeProof_V1& operator=(PailAffGroupEleRangeProof_V1&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailAffGroupEleRangeProof_V1& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailAffGroupEleRangeProof_V1* internal_default_instance() {
    return reinterpret_cast<const PailAffGroupEleRangeProof_V1*>(
               &_PailAffGroupEleRangeProof_V1_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PailAffGroupEleRangeProof_V1& a, PailAffGroupEleRangeProof_V1& b) {
    a.Swap(&b);
  }
  inline void Swap(PailAffGroupEleRangeProof_V1* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailAffGroupEleRangeProof_V1* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailAffGroupEleRangeProof_V1* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailAffGroupEleRangeProof_V1>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailAffGroupEleRangeProof_V1& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailAffGroupEleRangeProof_V1& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailAffGroupEleRangeProof_V1* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailAffGroupEleRangeProof_V1";
  }
  protected:
  explicit PailAffGroupEleRangeProof_V1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 2,
    kZPrimeFieldNumber = 3,
    kTFieldNumber = 4,
    kVFieldNumber = 5,
    kWFieldNumber = 6,
    kSFieldNumber = 7,
    kS1FieldNumber = 8,
    kS2FieldNumber = 9,
    kT1FieldNumber = 10,
    kT2FieldNumber = 11,
    kUFieldNumber = 1,
  };
  // string z = 2;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string z_prime = 3;
  void clear_z_prime();
  const std::string& z_prime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z_prime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z_prime();
  PROTOBUF_NODISCARD std::string* release_z_prime();
  void set_allocated_z_prime(std::string* z_prime);
  private:
  const std::string& _internal_z_prime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z_prime(const std::string& value);
  std::string* _internal_mutable_z_prime();
  public:

  // string t = 4;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string v = 5;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // string w = 6;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string s = 7;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string s1 = 8;
  void clear_s1();
  const std::string& s1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s1();
  PROTOBUF_NODISCARD std::string* release_s1();
  void set_allocated_s1(std::string* s1);
  private:
  const std::string& _internal_s1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s1(const std::string& value);
  std::string* _internal_mutable_s1();
  public:

  // string s2 = 9;
  void clear_s2();
  const std::string& s2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s2();
  PROTOBUF_NODISCARD std::string* release_s2();
  void set_allocated_s2(std::string* s2);
  private:
  const std::string& _internal_s2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s2(const std::string& value);
  std::string* _internal_mutable_s2();
  public:

  // string t1 = 10;
  void clear_t1();
  const std::string& t1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t1();
  PROTOBUF_NODISCARD std::string* release_t1();
  void set_allocated_t1(std::string* t1);
  private:
  const std::string& _internal_t1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t1(const std::string& value);
  std::string* _internal_mutable_t1();
  public:

  // string t2 = 11;
  void clear_t2();
  const std::string& t2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t2();
  PROTOBUF_NODISCARD std::string* release_t2();
  void set_allocated_t2(std::string* t2);
  private:
  const std::string& _internal_t2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t2(const std::string& value);
  std::string* _internal_mutable_t2();
  public:

  // .safeheron.proto.CurvePoint u = 1;
  bool has_u() const;
  private:
  bool _internal_has_u() const;
  public:
  void clear_u();
  const ::safeheron::proto::CurvePoint& u() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_u();
  ::safeheron::proto::CurvePoint* mutable_u();
  void set_allocated_u(::safeheron::proto::CurvePoint* u);
  private:
  const ::safeheron::proto::CurvePoint& _internal_u() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_u();
  public:
  void unsafe_arena_set_allocated_u(
      ::safeheron::proto::CurvePoint* u);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_u();

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailAffGroupEleRangeProof_V1)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_prime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t2_;
  ::safeheron::proto::CurvePoint* u_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailAffGroupEleRangeProof_V2 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailAffGroupEleRangeProof_V2) */ {
 public:
  inline PailAffGroupEleRangeProof_V2() : PailAffGroupEleRangeProof_V2(nullptr) {}
  ~PailAffGroupEleRangeProof_V2() override;
  explicit PROTOBUF_CONSTEXPR PailAffGroupEleRangeProof_V2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailAffGroupEleRangeProof_V2(const PailAffGroupEleRangeProof_V2& from);
  PailAffGroupEleRangeProof_V2(PailAffGroupEleRangeProof_V2&& from) noexcept
    : PailAffGroupEleRangeProof_V2() {
    *this = ::std::move(from);
  }

  inline PailAffGroupEleRangeProof_V2& operator=(const PailAffGroupEleRangeProof_V2& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailAffGroupEleRangeProof_V2& operator=(PailAffGroupEleRangeProof_V2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailAffGroupEleRangeProof_V2& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailAffGroupEleRangeProof_V2* internal_default_instance() {
    return reinterpret_cast<const PailAffGroupEleRangeProof_V2*>(
               &_PailAffGroupEleRangeProof_V2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PailAffGroupEleRangeProof_V2& a, PailAffGroupEleRangeProof_V2& b) {
    a.Swap(&b);
  }
  inline void Swap(PailAffGroupEleRangeProof_V2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailAffGroupEleRangeProof_V2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailAffGroupEleRangeProof_V2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailAffGroupEleRangeProof_V2>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailAffGroupEleRangeProof_V2& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailAffGroupEleRangeProof_V2& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailAffGroupEleRangeProof_V2* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailAffGroupEleRangeProof_V2";
  }
  protected:
  explicit PailAffGroupEleRangeProof_V2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kTFieldNumber = 2,
    kAFieldNumber = 3,
    kByFieldNumber = 5,
    kEFieldNumber = 6,
    kFFieldNumber = 7,
    kZ1FieldNumber = 8,
    kZ2FieldNumber = 9,
    kZ3FieldNumber = 10,
    kZ4FieldNumber = 11,
    kWFieldNumber = 12,
    kWyFieldNumber = 13,
    kBxFieldNumber = 4,
  };
  // string S = 1;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string T = 2;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string A = 3;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string By = 5;
  void clear_by();
  const std::string& by() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_by(ArgT0&& arg0, ArgT... args);
  std::string* mutable_by();
  PROTOBUF_NODISCARD std::string* release_by();
  void set_allocated_by(std::string* by);
  private:
  const std::string& _internal_by() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_by(const std::string& value);
  std::string* _internal_mutable_by();
  public:

  // string E = 6;
  void clear_e();
  const std::string& e() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e();
  PROTOBUF_NODISCARD std::string* release_e();
  void set_allocated_e(std::string* e);
  private:
  const std::string& _internal_e() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e(const std::string& value);
  std::string* _internal_mutable_e();
  public:

  // string F = 7;
  void clear_f();
  const std::string& f() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f();
  PROTOBUF_NODISCARD std::string* release_f();
  void set_allocated_f(std::string* f);
  private:
  const std::string& _internal_f() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f(const std::string& value);
  std::string* _internal_mutable_f();
  public:

  // string z1 = 8;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 9;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string z3 = 10;
  void clear_z3();
  const std::string& z3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z3();
  PROTOBUF_NODISCARD std::string* release_z3();
  void set_allocated_z3(std::string* z3);
  private:
  const std::string& _internal_z3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z3(const std::string& value);
  std::string* _internal_mutable_z3();
  public:

  // string z4 = 11;
  void clear_z4();
  const std::string& z4() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z4(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z4();
  PROTOBUF_NODISCARD std::string* release_z4();
  void set_allocated_z4(std::string* z4);
  private:
  const std::string& _internal_z4() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z4(const std::string& value);
  std::string* _internal_mutable_z4();
  public:

  // string w = 12;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string wy = 13;
  void clear_wy();
  const std::string& wy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_wy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_wy();
  PROTOBUF_NODISCARD std::string* release_wy();
  void set_allocated_wy(std::string* wy);
  private:
  const std::string& _internal_wy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wy(const std::string& value);
  std::string* _internal_mutable_wy();
  public:

  // .safeheron.proto.CurvePoint Bx = 4;
  bool has_bx() const;
  private:
  bool _internal_has_bx() const;
  public:
  void clear_bx();
  const ::safeheron::proto::CurvePoint& bx() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_bx();
  ::safeheron::proto::CurvePoint* mutable_bx();
  void set_allocated_bx(::safeheron::proto::CurvePoint* bx);
  private:
  const ::safeheron::proto::CurvePoint& _internal_bx() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_bx();
  public:
  void unsafe_arena_set_allocated_bx(
      ::safeheron::proto::CurvePoint* bx);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_bx();

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailAffGroupEleRangeProof_V2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr by_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z3_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z4_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wy_;
  ::safeheron::proto::CurvePoint* bx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class DlogEqualityProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DlogEqualityProof) */ {
 public:
  inline DlogEqualityProof() : DlogEqualityProof(nullptr) {}
  ~DlogEqualityProof() override;
  explicit PROTOBUF_CONSTEXPR DlogEqualityProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DlogEqualityProof(const DlogEqualityProof& from);
  DlogEqualityProof(DlogEqualityProof&& from) noexcept
    : DlogEqualityProof() {
    *this = ::std::move(from);
  }

  inline DlogEqualityProof& operator=(const DlogEqualityProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline DlogEqualityProof& operator=(DlogEqualityProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DlogEqualityProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const DlogEqualityProof* internal_default_instance() {
    return reinterpret_cast<const DlogEqualityProof*>(
               &_DlogEqualityProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DlogEqualityProof& a, DlogEqualityProof& b) {
    a.Swap(&b);
  }
  inline void Swap(DlogEqualityProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DlogEqualityProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DlogEqualityProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DlogEqualityProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DlogEqualityProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DlogEqualityProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DlogEqualityProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DlogEqualityProof";
  }
  protected:
  explicit DlogEqualityProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 3,
    kAFieldNumber = 1,
    kBFieldNumber = 2,
  };
  // string z = 3;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // .safeheron.proto.CurvePoint A = 1;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  const ::safeheron::proto::CurvePoint& a() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_a();
  ::safeheron::proto::CurvePoint* mutable_a();
  void set_allocated_a(::safeheron::proto::CurvePoint* a);
  private:
  const ::safeheron::proto::CurvePoint& _internal_a() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::safeheron::proto::CurvePoint* a);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_a();

  // .safeheron.proto.CurvePoint B = 2;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const ::safeheron::proto::CurvePoint& b() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_b();
  ::safeheron::proto::CurvePoint* mutable_b();
  void set_allocated_b(::safeheron::proto::CurvePoint* b);
  private:
  const ::safeheron::proto::CurvePoint& _internal_b() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_b();
  public:
  void unsafe_arena_set_allocated_b(
      ::safeheron::proto::CurvePoint* b);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_b();

  // @@protoc_insertion_point(class_scope:safeheron.proto.DlogEqualityProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::safeheron::proto::CurvePoint* a_;
  ::safeheron::proto::CurvePoint* b_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class DlogElGamalComProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.DlogElGamalComProof) */ {
 public:
  inline DlogElGamalComProof() : DlogElGamalComProof(nullptr) {}
  ~DlogElGamalComProof() override;
  explicit PROTOBUF_CONSTEXPR DlogElGamalComProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DlogElGamalComProof(const DlogElGamalComProof& from);
  DlogElGamalComProof(DlogElGamalComProof&& from) noexcept
    : DlogElGamalComProof() {
    *this = ::std::move(from);
  }

  inline DlogElGamalComProof& operator=(const DlogElGamalComProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline DlogElGamalComProof& operator=(DlogElGamalComProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DlogElGamalComProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const DlogElGamalComProof* internal_default_instance() {
    return reinterpret_cast<const DlogElGamalComProof*>(
               &_DlogElGamalComProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DlogElGamalComProof& a, DlogElGamalComProof& b) {
    a.Swap(&b);
  }
  inline void Swap(DlogElGamalComProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DlogElGamalComProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DlogElGamalComProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DlogElGamalComProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DlogElGamalComProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DlogElGamalComProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DlogElGamalComProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.DlogElGamalComProof";
  }
  protected:
  explicit DlogElGamalComProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZFieldNumber = 4,
    kUFieldNumber = 5,
    kAFieldNumber = 1,
    kNFieldNumber = 2,
    kBFieldNumber = 3,
  };
  // string z = 4;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string u = 5;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // .safeheron.proto.CurvePoint A = 1;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  const ::safeheron::proto::CurvePoint& a() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_a();
  ::safeheron::proto::CurvePoint* mutable_a();
  void set_allocated_a(::safeheron::proto::CurvePoint* a);
  private:
  const ::safeheron::proto::CurvePoint& _internal_a() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::safeheron::proto::CurvePoint* a);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_a();

  // .safeheron.proto.CurvePoint N = 2;
  bool has_n() const;
  private:
  bool _internal_has_n() const;
  public:
  void clear_n();
  const ::safeheron::proto::CurvePoint& n() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_n();
  ::safeheron::proto::CurvePoint* mutable_n();
  void set_allocated_n(::safeheron::proto::CurvePoint* n);
  private:
  const ::safeheron::proto::CurvePoint& _internal_n() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_n();
  public:
  void unsafe_arena_set_allocated_n(
      ::safeheron::proto::CurvePoint* n);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_n();

  // .safeheron.proto.CurvePoint B = 3;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const ::safeheron::proto::CurvePoint& b() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_b();
  ::safeheron::proto::CurvePoint* mutable_b();
  void set_allocated_b(::safeheron::proto::CurvePoint* b);
  private:
  const ::safeheron::proto::CurvePoint& _internal_b() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_b();
  public:
  void unsafe_arena_set_allocated_b(
      ::safeheron::proto::CurvePoint* b);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_b();

  // @@protoc_insertion_point(class_scope:safeheron.proto.DlogElGamalComProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::safeheron::proto::CurvePoint* a_;
  ::safeheron::proto::CurvePoint* n_;
  ::safeheron::proto::CurvePoint* b_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncElGamalComRangeProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncElGamalComRangeProof) */ {
 public:
  inline PailEncElGamalComRangeProof() : PailEncElGamalComRangeProof(nullptr) {}
  ~PailEncElGamalComRangeProof() override;
  explicit PROTOBUF_CONSTEXPR PailEncElGamalComRangeProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncElGamalComRangeProof(const PailEncElGamalComRangeProof& from);
  PailEncElGamalComRangeProof(PailEncElGamalComRangeProof&& from) noexcept
    : PailEncElGamalComRangeProof() {
    *this = ::std::move(from);
  }

  inline PailEncElGamalComRangeProof& operator=(const PailEncElGamalComRangeProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncElGamalComRangeProof& operator=(PailEncElGamalComRangeProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncElGamalComRangeProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncElGamalComRangeProof* internal_default_instance() {
    return reinterpret_cast<const PailEncElGamalComRangeProof*>(
               &_PailEncElGamalComRangeProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PailEncElGamalComRangeProof& a, PailEncElGamalComRangeProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncElGamalComRangeProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncElGamalComRangeProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncElGamalComRangeProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncElGamalComRangeProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncElGamalComRangeProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncElGamalComRangeProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncElGamalComRangeProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncElGamalComRangeProof";
  }
  protected:
  explicit PailEncElGamalComRangeProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kDFieldNumber = 2,
    kTFieldNumber = 5,
    kZ1FieldNumber = 6,
    kWFieldNumber = 7,
    kZ2FieldNumber = 8,
    kZ3FieldNumber = 9,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
  };
  // string S = 1;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string D = 2;
  void clear_d();
  const std::string& d() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_d(ArgT0&& arg0, ArgT... args);
  std::string* mutable_d();
  PROTOBUF_NODISCARD std::string* release_d();
  void set_allocated_d(std::string* d);
  private:
  const std::string& _internal_d() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_d(const std::string& value);
  std::string* _internal_mutable_d();
  public:

  // string T = 5;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string z1 = 6;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string w = 7;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // string z2 = 8;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string z3 = 9;
  void clear_z3();
  const std::string& z3() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z3(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z3();
  PROTOBUF_NODISCARD std::string* release_z3();
  void set_allocated_z3(std::string* z3);
  private:
  const std::string& _internal_z3() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z3(const std::string& value);
  std::string* _internal_mutable_z3();
  public:

  // .safeheron.proto.CurvePoint Y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::safeheron::proto::CurvePoint& y() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_y();
  ::safeheron::proto::CurvePoint* mutable_y();
  void set_allocated_y(::safeheron::proto::CurvePoint* y);
  private:
  const ::safeheron::proto::CurvePoint& _internal_y() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::safeheron::proto::CurvePoint* y);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_y();

  // .safeheron.proto.CurvePoint Z = 4;
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  const ::safeheron::proto::CurvePoint& z() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_z();
  ::safeheron::proto::CurvePoint* mutable_z();
  void set_allocated_z(::safeheron::proto::CurvePoint* z);
  private:
  const ::safeheron::proto::CurvePoint& _internal_z() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_z();
  public:
  void unsafe_arena_set_allocated_z(
      ::safeheron::proto::CurvePoint* z);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncElGamalComRangeProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr d_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z3_;
  ::safeheron::proto::CurvePoint* y_;
  ::safeheron::proto::CurvePoint* z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class NoSmallFactorProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.NoSmallFactorProof) */ {
 public:
  inline NoSmallFactorProof() : NoSmallFactorProof(nullptr) {}
  ~NoSmallFactorProof() override;
  explicit PROTOBUF_CONSTEXPR NoSmallFactorProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NoSmallFactorProof(const NoSmallFactorProof& from);
  NoSmallFactorProof(NoSmallFactorProof&& from) noexcept
    : NoSmallFactorProof() {
    *this = ::std::move(from);
  }

  inline NoSmallFactorProof& operator=(const NoSmallFactorProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline NoSmallFactorProof& operator=(NoSmallFactorProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NoSmallFactorProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const NoSmallFactorProof* internal_default_instance() {
    return reinterpret_cast<const NoSmallFactorProof*>(
               &_NoSmallFactorProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(NoSmallFactorProof& a, NoSmallFactorProof& b) {
    a.Swap(&b);
  }
  inline void Swap(NoSmallFactorProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NoSmallFactorProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NoSmallFactorProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NoSmallFactorProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NoSmallFactorProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NoSmallFactorProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NoSmallFactorProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.NoSmallFactorProof";
  }
  protected:
  explicit NoSmallFactorProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPFieldNumber = 1,
    kQFieldNumber = 2,
    kAFieldNumber = 3,
    kBFieldNumber = 4,
    kTFieldNumber = 5,
    kSigmaFieldNumber = 6,
    kZ1FieldNumber = 7,
    kZ2FieldNumber = 8,
    kW1FieldNumber = 9,
    kW2FieldNumber = 10,
    kVFieldNumber = 11,
  };
  // string P = 1;
  void clear_p();
  const std::string& p() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_p(ArgT0&& arg0, ArgT... args);
  std::string* mutable_p();
  PROTOBUF_NODISCARD std::string* release_p();
  void set_allocated_p(std::string* p);
  private:
  const std::string& _internal_p() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_p(const std::string& value);
  std::string* _internal_mutable_p();
  public:

  // string Q = 2;
  void clear_q();
  const std::string& q() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_q(ArgT0&& arg0, ArgT... args);
  std::string* mutable_q();
  PROTOBUF_NODISCARD std::string* release_q();
  void set_allocated_q(std::string* q);
  private:
  const std::string& _internal_q() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_q(const std::string& value);
  std::string* _internal_mutable_q();
  public:

  // string A = 3;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string B = 4;
  void clear_b();
  const std::string& b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_b();
  PROTOBUF_NODISCARD std::string* release_b();
  void set_allocated_b(std::string* b);
  private:
  const std::string& _internal_b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_b(const std::string& value);
  std::string* _internal_mutable_b();
  public:

  // string T = 5;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string sigma = 6;
  void clear_sigma();
  const std::string& sigma() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sigma(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sigma();
  PROTOBUF_NODISCARD std::string* release_sigma();
  void set_allocated_sigma(std::string* sigma);
  private:
  const std::string& _internal_sigma() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sigma(const std::string& value);
  std::string* _internal_mutable_sigma();
  public:

  // string z1 = 7;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 8;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string w1 = 9;
  void clear_w1();
  const std::string& w1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w1();
  PROTOBUF_NODISCARD std::string* release_w1();
  void set_allocated_w1(std::string* w1);
  private:
  const std::string& _internal_w1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w1(const std::string& value);
  std::string* _internal_mutable_w1();
  public:

  // string w2 = 10;
  void clear_w2();
  const std::string& w2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w2();
  PROTOBUF_NODISCARD std::string* release_w2();
  void set_allocated_w2(std::string* w2);
  private:
  const std::string& _internal_w2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w2(const std::string& value);
  std::string* _internal_mutable_w2();
  public:

  // string v = 11;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.NoSmallFactorProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr q_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sigma_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailBlumModulusProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailBlumModulusProof) */ {
 public:
  inline PailBlumModulusProof() : PailBlumModulusProof(nullptr) {}
  ~PailBlumModulusProof() override;
  explicit PROTOBUF_CONSTEXPR PailBlumModulusProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailBlumModulusProof(const PailBlumModulusProof& from);
  PailBlumModulusProof(PailBlumModulusProof&& from) noexcept
    : PailBlumModulusProof() {
    *this = ::std::move(from);
  }

  inline PailBlumModulusProof& operator=(const PailBlumModulusProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailBlumModulusProof& operator=(PailBlumModulusProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailBlumModulusProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailBlumModulusProof* internal_default_instance() {
    return reinterpret_cast<const PailBlumModulusProof*>(
               &_PailBlumModulusProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PailBlumModulusProof& a, PailBlumModulusProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailBlumModulusProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailBlumModulusProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailBlumModulusProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailBlumModulusProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailBlumModulusProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailBlumModulusProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailBlumModulusProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailBlumModulusProof";
  }
  protected:
  explicit PailBlumModulusProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXArrFieldNumber = 1,
    kAArrFieldNumber = 2,
    kBArrFieldNumber = 3,
    kZArrFieldNumber = 4,
    kWFieldNumber = 5,
  };
  // repeated string x_arr = 1;
  int x_arr_size() const;
  private:
  int _internal_x_arr_size() const;
  public:
  void clear_x_arr();
  const std::string& x_arr(int index) const;
  std::string* mutable_x_arr(int index);
  void set_x_arr(int index, const std::string& value);
  void set_x_arr(int index, std::string&& value);
  void set_x_arr(int index, const char* value);
  void set_x_arr(int index, const char* value, size_t size);
  std::string* add_x_arr();
  void add_x_arr(const std::string& value);
  void add_x_arr(std::string&& value);
  void add_x_arr(const char* value);
  void add_x_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& x_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_x_arr();
  private:
  const std::string& _internal_x_arr(int index) const;
  std::string* _internal_add_x_arr();
  public:

  // repeated int32 a_arr = 2;
  int a_arr_size() const;
  private:
  int _internal_a_arr_size() const;
  public:
  void clear_a_arr();
  private:
  int32_t _internal_a_arr(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_a_arr() const;
  void _internal_add_a_arr(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_a_arr();
  public:
  int32_t a_arr(int index) const;
  void set_a_arr(int index, int32_t value);
  void add_a_arr(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      a_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_a_arr();

  // repeated int32 b_arr = 3;
  int b_arr_size() const;
  private:
  int _internal_b_arr_size() const;
  public:
  void clear_b_arr();
  private:
  int32_t _internal_b_arr(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_b_arr() const;
  void _internal_add_b_arr(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_b_arr();
  public:
  int32_t b_arr(int index) const;
  void set_b_arr(int index, int32_t value);
  void add_b_arr(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      b_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_b_arr();

  // repeated string z_arr = 4;
  int z_arr_size() const;
  private:
  int _internal_z_arr_size() const;
  public:
  void clear_z_arr();
  const std::string& z_arr(int index) const;
  std::string* mutable_z_arr(int index);
  void set_z_arr(int index, const std::string& value);
  void set_z_arr(int index, std::string&& value);
  void set_z_arr(int index, const char* value);
  void set_z_arr(int index, const char* value, size_t size);
  std::string* add_z_arr();
  void add_z_arr(const std::string& value);
  void add_z_arr(std::string&& value);
  void add_z_arr(const char* value);
  void add_z_arr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& z_arr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_z_arr();
  private:
  const std::string& _internal_z_arr(int index) const;
  std::string* _internal_add_z_arr();
  public:

  // string w = 5;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailBlumModulusProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> x_arr_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > a_arr_;
  mutable std::atomic<int> _a_arr_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > b_arr_;
  mutable std::atomic<int> _b_arr_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> z_arr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailDecModuloProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailDecModuloProof) */ {
 public:
  inline PailDecModuloProof() : PailDecModuloProof(nullptr) {}
  ~PailDecModuloProof() override;
  explicit PROTOBUF_CONSTEXPR PailDecModuloProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailDecModuloProof(const PailDecModuloProof& from);
  PailDecModuloProof(PailDecModuloProof&& from) noexcept
    : PailDecModuloProof() {
    *this = ::std::move(from);
  }

  inline PailDecModuloProof& operator=(const PailDecModuloProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailDecModuloProof& operator=(PailDecModuloProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailDecModuloProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailDecModuloProof* internal_default_instance() {
    return reinterpret_cast<const PailDecModuloProof*>(
               &_PailDecModuloProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PailDecModuloProof& a, PailDecModuloProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailDecModuloProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailDecModuloProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailDecModuloProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailDecModuloProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailDecModuloProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailDecModuloProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailDecModuloProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailDecModuloProof";
  }
  protected:
  explicit PailDecModuloProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kTFieldNumber = 2,
    kAFieldNumber = 3,
    kGammaFieldNumber = 4,
    kZ1FieldNumber = 5,
    kZ2FieldNumber = 6,
    kWFieldNumber = 7,
  };
  // string S = 1;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string T = 2;
  void clear_t();
  const std::string& t() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_t(ArgT0&& arg0, ArgT... args);
  std::string* mutable_t();
  PROTOBUF_NODISCARD std::string* release_t();
  void set_allocated_t(std::string* t);
  private:
  const std::string& _internal_t() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_t(const std::string& value);
  std::string* _internal_mutable_t();
  public:

  // string A = 3;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string gamma = 4;
  void clear_gamma();
  const std::string& gamma() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamma(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamma();
  PROTOBUF_NODISCARD std::string* release_gamma();
  void set_allocated_gamma(std::string* gamma);
  private:
  const std::string& _internal_gamma() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamma(const std::string& value);
  std::string* _internal_mutable_gamma();
  public:

  // string z1 = 5;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 6;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string w = 7;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailDecModuloProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr t_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamma_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailEncMulProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailEncMulProof) */ {
 public:
  inline PailEncMulProof() : PailEncMulProof(nullptr) {}
  ~PailEncMulProof() override;
  explicit PROTOBUF_CONSTEXPR PailEncMulProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailEncMulProof(const PailEncMulProof& from);
  PailEncMulProof(PailEncMulProof&& from) noexcept
    : PailEncMulProof() {
    *this = ::std::move(from);
  }

  inline PailEncMulProof& operator=(const PailEncMulProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailEncMulProof& operator=(PailEncMulProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailEncMulProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailEncMulProof* internal_default_instance() {
    return reinterpret_cast<const PailEncMulProof*>(
               &_PailEncMulProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PailEncMulProof& a, PailEncMulProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailEncMulProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailEncMulProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailEncMulProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailEncMulProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailEncMulProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailEncMulProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailEncMulProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailEncMulProof";
  }
  protected:
  explicit PailEncMulProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 1,
    kBFieldNumber = 2,
    kZFieldNumber = 3,
    kUFieldNumber = 4,
    kVFieldNumber = 5,
  };
  // string A = 1;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string B = 2;
  void clear_b();
  const std::string& b() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_b(ArgT0&& arg0, ArgT... args);
  std::string* mutable_b();
  PROTOBUF_NODISCARD std::string* release_b();
  void set_allocated_b(std::string* b);
  private:
  const std::string& _internal_b() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_b(const std::string& value);
  std::string* _internal_mutable_b();
  public:

  // string z = 3;
  void clear_z();
  const std::string& z() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z();
  PROTOBUF_NODISCARD std::string* release_z();
  void set_allocated_z(std::string* z);
  private:
  const std::string& _internal_z() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z(const std::string& value);
  std::string* _internal_mutable_z();
  public:

  // string u = 4;
  void clear_u();
  const std::string& u() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u();
  PROTOBUF_NODISCARD std::string* release_u();
  void set_allocated_u(std::string* u);
  private:
  const std::string& _internal_u() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u(const std::string& value);
  std::string* _internal_mutable_u();
  public:

  // string v = 5;
  void clear_v();
  const std::string& v() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_v(ArgT0&& arg0, ArgT... args);
  std::string* mutable_v();
  PROTOBUF_NODISCARD std::string* release_v();
  void set_allocated_v(std::string* v);
  private:
  const std::string& _internal_v() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_v(const std::string& value);
  std::string* _internal_mutable_v();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailEncMulProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr v_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// -------------------------------------------------------------------

class PailMulGroupEleRangeProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.PailMulGroupEleRangeProof) */ {
 public:
  inline PailMulGroupEleRangeProof() : PailMulGroupEleRangeProof(nullptr) {}
  ~PailMulGroupEleRangeProof() override;
  explicit PROTOBUF_CONSTEXPR PailMulGroupEleRangeProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PailMulGroupEleRangeProof(const PailMulGroupEleRangeProof& from);
  PailMulGroupEleRangeProof(PailMulGroupEleRangeProof&& from) noexcept
    : PailMulGroupEleRangeProof() {
    *this = ::std::move(from);
  }

  inline PailMulGroupEleRangeProof& operator=(const PailMulGroupEleRangeProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline PailMulGroupEleRangeProof& operator=(PailMulGroupEleRangeProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PailMulGroupEleRangeProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const PailMulGroupEleRangeProof* internal_default_instance() {
    return reinterpret_cast<const PailMulGroupEleRangeProof*>(
               &_PailMulGroupEleRangeProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PailMulGroupEleRangeProof& a, PailMulGroupEleRangeProof& b) {
    a.Swap(&b);
  }
  inline void Swap(PailMulGroupEleRangeProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PailMulGroupEleRangeProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PailMulGroupEleRangeProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PailMulGroupEleRangeProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PailMulGroupEleRangeProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PailMulGroupEleRangeProof& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PailMulGroupEleRangeProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.PailMulGroupEleRangeProof";
  }
  protected:
  explicit PailMulGroupEleRangeProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAFieldNumber = 1,
    kEFieldNumber = 3,
    kSFieldNumber = 4,
    kZ1FieldNumber = 5,
    kZ2FieldNumber = 6,
    kWFieldNumber = 7,
    kBFieldNumber = 2,
  };
  // string A = 1;
  void clear_a();
  const std::string& a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_a();
  PROTOBUF_NODISCARD std::string* release_a();
  void set_allocated_a(std::string* a);
  private:
  const std::string& _internal_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_a(const std::string& value);
  std::string* _internal_mutable_a();
  public:

  // string E = 3;
  void clear_e();
  const std::string& e() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_e(ArgT0&& arg0, ArgT... args);
  std::string* mutable_e();
  PROTOBUF_NODISCARD std::string* release_e();
  void set_allocated_e(std::string* e);
  private:
  const std::string& _internal_e() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_e(const std::string& value);
  std::string* _internal_mutable_e();
  public:

  // string S = 4;
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // string z1 = 5;
  void clear_z1();
  const std::string& z1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z1();
  PROTOBUF_NODISCARD std::string* release_z1();
  void set_allocated_z1(std::string* z1);
  private:
  const std::string& _internal_z1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z1(const std::string& value);
  std::string* _internal_mutable_z1();
  public:

  // string z2 = 6;
  void clear_z2();
  const std::string& z2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z2();
  PROTOBUF_NODISCARD std::string* release_z2();
  void set_allocated_z2(std::string* z2);
  private:
  const std::string& _internal_z2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z2(const std::string& value);
  std::string* _internal_mutable_z2();
  public:

  // string w = 7;
  void clear_w();
  const std::string& w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_w();
  PROTOBUF_NODISCARD std::string* release_w();
  void set_allocated_w(std::string* w);
  private:
  const std::string& _internal_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_w(const std::string& value);
  std::string* _internal_mutable_w();
  public:

  // .safeheron.proto.CurvePoint B = 2;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const ::safeheron::proto::CurvePoint& b() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_b();
  ::safeheron::proto::CurvePoint* mutable_b();
  void set_allocated_b(::safeheron::proto::CurvePoint* b);
  private:
  const ::safeheron::proto::CurvePoint& _internal_b() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_b();
  public:
  void unsafe_arena_set_allocated_b(
      ::safeheron::proto::CurvePoint* b);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_b();

  // @@protoc_insertion_point(class_scope:safeheron.proto.PailMulGroupEleRangeProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr e_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z2_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr w_;
  ::safeheron::proto::CurvePoint* b_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_zkp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DLogProof

// .safeheron.proto.CurvePoint pk = 1;
inline bool DLogProof::_internal_has_pk() const {
  return this != internal_default_instance() && pk_ != nullptr;
}
inline bool DLogProof::has_pk() const {
  return _internal_has_pk();
}
inline const ::safeheron::proto::CurvePoint& DLogProof::_internal_pk() const {
  const ::safeheron::proto::CurvePoint* p = pk_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DLogProof::pk() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof.pk)
  return _internal_pk();
}
inline void DLogProof::unsafe_arena_set_allocated_pk(
    ::safeheron::proto::CurvePoint* pk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pk_);
  }
  pk_ = pk;
  if (pk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DLogProof.pk)
}
inline ::safeheron::proto::CurvePoint* DLogProof::release_pk() {
  
  ::safeheron::proto::CurvePoint* temp = pk_;
  pk_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::unsafe_arena_release_pk() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof.pk)
  
  ::safeheron::proto::CurvePoint* temp = pk_;
  pk_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::_internal_mutable_pk() {
  
  if (pk_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    pk_ = p;
  }
  return pk_;
}
inline ::safeheron::proto::CurvePoint* DLogProof::mutable_pk() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_pk();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof.pk)
  return _msg;
}
inline void DLogProof::set_allocated_pk(::safeheron::proto::CurvePoint* pk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pk_);
  }
  if (pk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pk));
    if (message_arena != submessage_arena) {
      pk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pk, submessage_arena);
    }
    
  } else {
    
  }
  pk_ = pk;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof.pk)
}

// .safeheron.proto.CurvePoint g_r = 2;
inline bool DLogProof::_internal_has_g_r() const {
  return this != internal_default_instance() && g_r_ != nullptr;
}
inline bool DLogProof::has_g_r() const {
  return _internal_has_g_r();
}
inline const ::safeheron::proto::CurvePoint& DLogProof::_internal_g_r() const {
  const ::safeheron::proto::CurvePoint* p = g_r_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DLogProof::g_r() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof.g_r)
  return _internal_g_r();
}
inline void DLogProof::unsafe_arena_set_allocated_g_r(
    ::safeheron::proto::CurvePoint* g_r) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(g_r_);
  }
  g_r_ = g_r;
  if (g_r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DLogProof.g_r)
}
inline ::safeheron::proto::CurvePoint* DLogProof::release_g_r() {
  
  ::safeheron::proto::CurvePoint* temp = g_r_;
  g_r_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::unsafe_arena_release_g_r() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof.g_r)
  
  ::safeheron::proto::CurvePoint* temp = g_r_;
  g_r_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof::_internal_mutable_g_r() {
  
  if (g_r_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    g_r_ = p;
  }
  return g_r_;
}
inline ::safeheron::proto::CurvePoint* DLogProof::mutable_g_r() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_g_r();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof.g_r)
  return _msg;
}
inline void DLogProof::set_allocated_g_r(::safeheron::proto::CurvePoint* g_r) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(g_r_);
  }
  if (g_r) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(g_r));
    if (message_arena != submessage_arena) {
      g_r = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, g_r, submessage_arena);
    }
    
  } else {
    
  }
  g_r_ = g_r;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof.g_r)
}

// string res = 3;
inline void DLogProof::clear_res() {
  res_.ClearToEmpty();
}
inline const std::string& DLogProof::res() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof.res)
  return _internal_res();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLogProof::set_res(ArgT0&& arg0, ArgT... args) {
 
 res_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.DLogProof.res)
}
inline std::string* DLogProof::mutable_res() {
  std::string* _s = _internal_mutable_res();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof.res)
  return _s;
}
inline const std::string& DLogProof::_internal_res() const {
  return res_.Get();
}
inline void DLogProof::_internal_set_res(const std::string& value) {
  
  res_.Set(value, GetArenaForAllocation());
}
inline std::string* DLogProof::_internal_mutable_res() {
  
  return res_.Mutable(GetArenaForAllocation());
}
inline std::string* DLogProof::release_res() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof.res)
  return res_.Release();
}
inline void DLogProof::set_allocated_res(std::string* res) {
  if (res != nullptr) {
    
  } else {
    
  }
  res_.SetAllocated(res, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (res_.IsDefault()) {
    res_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof.res)
}

// -------------------------------------------------------------------

// DLogProof_V2

// .safeheron.proto.CurvePoint A = 2;
inline bool DLogProof_V2::_internal_has_a() const {
  return this != internal_default_instance() && a_ != nullptr;
}
inline bool DLogProof_V2::has_a() const {
  return _internal_has_a();
}
inline const ::safeheron::proto::CurvePoint& DLogProof_V2::_internal_a() const {
  const ::safeheron::proto::CurvePoint* p = a_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DLogProof_V2::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof_V2.A)
  return _internal_a();
}
inline void DLogProof_V2::unsafe_arena_set_allocated_a(
    ::safeheron::proto::CurvePoint* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  a_ = a;
  if (a) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DLogProof_V2.A)
}
inline ::safeheron::proto::CurvePoint* DLogProof_V2::release_a() {
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof_V2::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof_V2.A)
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DLogProof_V2::_internal_mutable_a() {
  
  if (a_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    a_ = p;
  }
  return a_;
}
inline ::safeheron::proto::CurvePoint* DLogProof_V2::mutable_a() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof_V2.A)
  return _msg;
}
inline void DLogProof_V2::set_allocated_a(::safeheron::proto::CurvePoint* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a));
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    
  } else {
    
  }
  a_ = a;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof_V2.A)
}

// string z = 3;
inline void DLogProof_V2::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& DLogProof_V2::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLogProof_V2.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DLogProof_V2::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.DLogProof_V2.z)
}
inline std::string* DLogProof_V2::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLogProof_V2.z)
  return _s;
}
inline const std::string& DLogProof_V2::_internal_z() const {
  return z_.Get();
}
inline void DLogProof_V2::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* DLogProof_V2::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* DLogProof_V2::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DLogProof_V2.z)
  return z_.Release();
}
inline void DLogProof_V2::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DLogProof_V2.z)
}

// -------------------------------------------------------------------

// HegProof

// .safeheron.proto.CurvePoint T = 1;
inline bool HegProof::_internal_has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline bool HegProof::has_t() const {
  return _internal_has_t();
}
inline const ::safeheron::proto::CurvePoint& HegProof::_internal_t() const {
  const ::safeheron::proto::CurvePoint* p = t_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HegProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.T)
  return _internal_t();
}
inline void HegProof::unsafe_arena_set_allocated_t(
    ::safeheron::proto::CurvePoint* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  t_ = t;
  if (t) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HegProof.T)
}
inline ::safeheron::proto::CurvePoint* HegProof::release_t() {
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.T)
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::_internal_mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    t_ = p;
  }
  return t_;
}
inline ::safeheron::proto::CurvePoint* HegProof::mutable_t() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.T)
  return _msg;
}
inline void HegProof::set_allocated_t(::safeheron::proto::CurvePoint* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t));
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.T)
}

// .safeheron.proto.CurvePoint A3 = 2;
inline bool HegProof::_internal_has_a3() const {
  return this != internal_default_instance() && a3_ != nullptr;
}
inline bool HegProof::has_a3() const {
  return _internal_has_a3();
}
inline const ::safeheron::proto::CurvePoint& HegProof::_internal_a3() const {
  const ::safeheron::proto::CurvePoint* p = a3_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HegProof::a3() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.A3)
  return _internal_a3();
}
inline void HegProof::unsafe_arena_set_allocated_a3(
    ::safeheron::proto::CurvePoint* a3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a3_);
  }
  a3_ = a3;
  if (a3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HegProof.A3)
}
inline ::safeheron::proto::CurvePoint* HegProof::release_a3() {
  
  ::safeheron::proto::CurvePoint* temp = a3_;
  a3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::unsafe_arena_release_a3() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.A3)
  
  ::safeheron::proto::CurvePoint* temp = a3_;
  a3_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HegProof::_internal_mutable_a3() {
  
  if (a3_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    a3_ = p;
  }
  return a3_;
}
inline ::safeheron::proto::CurvePoint* HegProof::mutable_a3() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_a3();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.A3)
  return _msg;
}
inline void HegProof::set_allocated_a3(::safeheron::proto::CurvePoint* a3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(a3_);
  }
  if (a3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a3));
    if (message_arena != submessage_arena) {
      a3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a3, submessage_arena);
    }
    
  } else {
    
  }
  a3_ = a3;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.A3)
}

// string z1 = 3;
inline void HegProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& HegProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HegProof::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.HegProof.z1)
}
inline std::string* HegProof::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.z1)
  return _s;
}
inline const std::string& HegProof::_internal_z1() const {
  return z1_.Get();
}
inline void HegProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* HegProof::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* HegProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.z1)
  return z1_.Release();
}
inline void HegProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.z1)
}

// string z2 = 4;
inline void HegProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& HegProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HegProof.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HegProof::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.HegProof.z2)
}
inline std::string* HegProof::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HegProof.z2)
  return _s;
}
inline const std::string& HegProof::_internal_z2() const {
  return z2_.Get();
}
inline void HegProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* HegProof::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* HegProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HegProof.z2)
  return z2_.Release();
}
inline void HegProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HegProof.z2)
}

// -------------------------------------------------------------------

// HEGProof_V2

// .safeheron.proto.CurvePoint Alpha = 1;
inline bool HEGProof_V2::_internal_has_alpha() const {
  return this != internal_default_instance() && alpha_ != nullptr;
}
inline bool HEGProof_V2::has_alpha() const {
  return _internal_has_alpha();
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V2::_internal_alpha() const {
  const ::safeheron::proto::CurvePoint* p = alpha_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V2::alpha() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V2.Alpha)
  return _internal_alpha();
}
inline void HEGProof_V2::unsafe_arena_set_allocated_alpha(
    ::safeheron::proto::CurvePoint* alpha) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  alpha_ = alpha;
  if (alpha) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HEGProof_V2.Alpha)
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::release_alpha() {
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::unsafe_arena_release_alpha() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V2.Alpha)
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::_internal_mutable_alpha() {
  
  if (alpha_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    alpha_ = p;
  }
  return alpha_;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::mutable_alpha() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V2.Alpha)
  return _msg;
}
inline void HEGProof_V2::set_allocated_alpha(::safeheron::proto::CurvePoint* alpha) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  if (alpha) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha));
    if (message_arena != submessage_arena) {
      alpha = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alpha, submessage_arena);
    }
    
  } else {
    
  }
  alpha_ = alpha;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V2.Alpha)
}

// .safeheron.proto.CurvePoint Beta = 2;
inline bool HEGProof_V2::_internal_has_beta() const {
  return this != internal_default_instance() && beta_ != nullptr;
}
inline bool HEGProof_V2::has_beta() const {
  return _internal_has_beta();
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V2::_internal_beta() const {
  const ::safeheron::proto::CurvePoint* p = beta_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V2::beta() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V2.Beta)
  return _internal_beta();
}
inline void HEGProof_V2::unsafe_arena_set_allocated_beta(
    ::safeheron::proto::CurvePoint* beta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(beta_);
  }
  beta_ = beta;
  if (beta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HEGProof_V2.Beta)
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::release_beta() {
  
  ::safeheron::proto::CurvePoint* temp = beta_;
  beta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::unsafe_arena_release_beta() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V2.Beta)
  
  ::safeheron::proto::CurvePoint* temp = beta_;
  beta_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::_internal_mutable_beta() {
  
  if (beta_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    beta_ = p;
  }
  return beta_;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V2::mutable_beta() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_beta();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V2.Beta)
  return _msg;
}
inline void HEGProof_V2::set_allocated_beta(::safeheron::proto::CurvePoint* beta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(beta_);
  }
  if (beta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(beta));
    if (message_arena != submessage_arena) {
      beta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, beta, submessage_arena);
    }
    
  } else {
    
  }
  beta_ = beta;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V2.Beta)
}

// string t = 3;
inline void HEGProof_V2::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& HEGProof_V2::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V2.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HEGProof_V2::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.HEGProof_V2.t)
}
inline std::string* HEGProof_V2::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V2.t)
  return _s;
}
inline const std::string& HEGProof_V2::_internal_t() const {
  return t_.Get();
}
inline void HEGProof_V2::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* HEGProof_V2::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* HEGProof_V2::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V2.t)
  return t_.Release();
}
inline void HEGProof_V2::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V2.t)
}

// string u = 4;
inline void HEGProof_V2::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& HEGProof_V2::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V2.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HEGProof_V2::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.HEGProof_V2.u)
}
inline std::string* HEGProof_V2::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V2.u)
  return _s;
}
inline const std::string& HEGProof_V2::_internal_u() const {
  return u_.Get();
}
inline void HEGProof_V2::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* HEGProof_V2::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* HEGProof_V2::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V2.u)
  return u_.Release();
}
inline void HEGProof_V2::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V2.u)
}

// -------------------------------------------------------------------

// LinearCombinationProof

// .safeheron.proto.CurvePoint Alpha = 1;
inline bool LinearCombinationProof::_internal_has_alpha() const {
  return this != internal_default_instance() && alpha_ != nullptr;
}
inline bool LinearCombinationProof::has_alpha() const {
  return _internal_has_alpha();
}
inline const ::safeheron::proto::CurvePoint& LinearCombinationProof::_internal_alpha() const {
  const ::safeheron::proto::CurvePoint* p = alpha_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& LinearCombinationProof::alpha() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.LinearCombinationProof.Alpha)
  return _internal_alpha();
}
inline void LinearCombinationProof::unsafe_arena_set_allocated_alpha(
    ::safeheron::proto::CurvePoint* alpha) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  alpha_ = alpha;
  if (alpha) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.LinearCombinationProof.Alpha)
}
inline ::safeheron::proto::CurvePoint* LinearCombinationProof::release_alpha() {
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* LinearCombinationProof::unsafe_arena_release_alpha() {
  // @@protoc_insertion_point(field_release:safeheron.proto.LinearCombinationProof.Alpha)
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* LinearCombinationProof::_internal_mutable_alpha() {
  
  if (alpha_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    alpha_ = p;
  }
  return alpha_;
}
inline ::safeheron::proto::CurvePoint* LinearCombinationProof::mutable_alpha() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.LinearCombinationProof.Alpha)
  return _msg;
}
inline void LinearCombinationProof::set_allocated_alpha(::safeheron::proto::CurvePoint* alpha) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  if (alpha) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha));
    if (message_arena != submessage_arena) {
      alpha = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alpha, submessage_arena);
    }
    
  } else {
    
  }
  alpha_ = alpha;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.LinearCombinationProof.Alpha)
}

// string t = 3;
inline void LinearCombinationProof::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& LinearCombinationProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.LinearCombinationProof.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinearCombinationProof::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.LinearCombinationProof.t)
}
inline std::string* LinearCombinationProof::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.LinearCombinationProof.t)
  return _s;
}
inline const std::string& LinearCombinationProof::_internal_t() const {
  return t_.Get();
}
inline void LinearCombinationProof::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* LinearCombinationProof::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* LinearCombinationProof::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.LinearCombinationProof.t)
  return t_.Release();
}
inline void LinearCombinationProof::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.LinearCombinationProof.t)
}

// string u = 4;
inline void LinearCombinationProof::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& LinearCombinationProof::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.LinearCombinationProof.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LinearCombinationProof::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.LinearCombinationProof.u)
}
inline std::string* LinearCombinationProof::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.LinearCombinationProof.u)
  return _s;
}
inline const std::string& LinearCombinationProof::_internal_u() const {
  return u_.Get();
}
inline void LinearCombinationProof::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* LinearCombinationProof::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* LinearCombinationProof::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.LinearCombinationProof.u)
  return u_.Release();
}
inline void LinearCombinationProof::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.LinearCombinationProof.u)
}

// -------------------------------------------------------------------

// HEGProof_V3

// .safeheron.proto.CurvePoint Alpha = 1;
inline bool HEGProof_V3::_internal_has_alpha() const {
  return this != internal_default_instance() && alpha_ != nullptr;
}
inline bool HEGProof_V3::has_alpha() const {
  return _internal_has_alpha();
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V3::_internal_alpha() const {
  const ::safeheron::proto::CurvePoint* p = alpha_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V3::alpha() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V3.Alpha)
  return _internal_alpha();
}
inline void HEGProof_V3::unsafe_arena_set_allocated_alpha(
    ::safeheron::proto::CurvePoint* alpha) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  alpha_ = alpha;
  if (alpha) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HEGProof_V3.Alpha)
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::release_alpha() {
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::unsafe_arena_release_alpha() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V3.Alpha)
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::_internal_mutable_alpha() {
  
  if (alpha_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    alpha_ = p;
  }
  return alpha_;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::mutable_alpha() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V3.Alpha)
  return _msg;
}
inline void HEGProof_V3::set_allocated_alpha(::safeheron::proto::CurvePoint* alpha) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  if (alpha) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha));
    if (message_arena != submessage_arena) {
      alpha = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alpha, submessage_arena);
    }
    
  } else {
    
  }
  alpha_ = alpha;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V3.Alpha)
}

// .safeheron.proto.CurvePoint Beta = 2;
inline bool HEGProof_V3::_internal_has_beta() const {
  return this != internal_default_instance() && beta_ != nullptr;
}
inline bool HEGProof_V3::has_beta() const {
  return _internal_has_beta();
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V3::_internal_beta() const {
  const ::safeheron::proto::CurvePoint* p = beta_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& HEGProof_V3::beta() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V3.Beta)
  return _internal_beta();
}
inline void HEGProof_V3::unsafe_arena_set_allocated_beta(
    ::safeheron::proto::CurvePoint* beta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(beta_);
  }
  beta_ = beta;
  if (beta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.HEGProof_V3.Beta)
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::release_beta() {
  
  ::safeheron::proto::CurvePoint* temp = beta_;
  beta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::unsafe_arena_release_beta() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V3.Beta)
  
  ::safeheron::proto::CurvePoint* temp = beta_;
  beta_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::_internal_mutable_beta() {
  
  if (beta_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    beta_ = p;
  }
  return beta_;
}
inline ::safeheron::proto::CurvePoint* HEGProof_V3::mutable_beta() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_beta();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V3.Beta)
  return _msg;
}
inline void HEGProof_V3::set_allocated_beta(::safeheron::proto::CurvePoint* beta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(beta_);
  }
  if (beta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(beta));
    if (message_arena != submessage_arena) {
      beta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, beta, submessage_arena);
    }
    
  } else {
    
  }
  beta_ = beta;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V3.Beta)
}

// string t = 3;
inline void HEGProof_V3::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& HEGProof_V3::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V3.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HEGProof_V3::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.HEGProof_V3.t)
}
inline std::string* HEGProof_V3::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V3.t)
  return _s;
}
inline const std::string& HEGProof_V3::_internal_t() const {
  return t_.Get();
}
inline void HEGProof_V3::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* HEGProof_V3::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* HEGProof_V3::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V3.t)
  return t_.Release();
}
inline void HEGProof_V3::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V3.t)
}

// string u = 4;
inline void HEGProof_V3::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& HEGProof_V3::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.HEGProof_V3.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HEGProof_V3::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.HEGProof_V3.u)
}
inline std::string* HEGProof_V3::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.HEGProof_V3.u)
  return _s;
}
inline const std::string& HEGProof_V3::_internal_u() const {
  return u_.Get();
}
inline void HEGProof_V3::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* HEGProof_V3::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* HEGProof_V3::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.HEGProof_V3.u)
  return u_.Release();
}
inline void HEGProof_V3::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.HEGProof_V3.u)
}

// -------------------------------------------------------------------

// PailProof

// repeated string y_N_arr = 1;
inline int PailProof::_internal_y_n_arr_size() const {
  return y_n_arr_.size();
}
inline int PailProof::y_n_arr_size() const {
  return _internal_y_n_arr_size();
}
inline void PailProof::clear_y_n_arr() {
  y_n_arr_.Clear();
}
inline std::string* PailProof::add_y_n_arr() {
  std::string* _s = _internal_add_y_n_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailProof.y_N_arr)
  return _s;
}
inline const std::string& PailProof::_internal_y_n_arr(int index) const {
  return y_n_arr_.Get(index);
}
inline const std::string& PailProof::y_n_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailProof.y_N_arr)
  return _internal_y_n_arr(index);
}
inline std::string* PailProof::mutable_y_n_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailProof.y_N_arr)
  return y_n_arr_.Mutable(index);
}
inline void PailProof::set_y_n_arr(int index, const std::string& value) {
  y_n_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::set_y_n_arr(int index, std::string&& value) {
  y_n_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::set_y_n_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_n_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::set_y_n_arr(int index, const char* value, size_t size) {
  y_n_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailProof.y_N_arr)
}
inline std::string* PailProof::_internal_add_y_n_arr() {
  return y_n_arr_.Add();
}
inline void PailProof::add_y_n_arr(const std::string& value) {
  y_n_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::add_y_n_arr(std::string&& value) {
  y_n_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::add_y_n_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_n_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailProof.y_N_arr)
}
inline void PailProof::add_y_n_arr(const char* value, size_t size) {
  y_n_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailProof.y_N_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailProof::y_n_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailProof.y_N_arr)
  return y_n_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailProof::mutable_y_n_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailProof.y_N_arr)
  return &y_n_arr_;
}

// -------------------------------------------------------------------

// PailNProof

// repeated string y_N_arr = 1;
inline int PailNProof::_internal_y_n_arr_size() const {
  return y_n_arr_.size();
}
inline int PailNProof::y_n_arr_size() const {
  return _internal_y_n_arr_size();
}
inline void PailNProof::clear_y_n_arr() {
  y_n_arr_.Clear();
}
inline std::string* PailNProof::add_y_n_arr() {
  std::string* _s = _internal_add_y_n_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailNProof.y_N_arr)
  return _s;
}
inline const std::string& PailNProof::_internal_y_n_arr(int index) const {
  return y_n_arr_.Get(index);
}
inline const std::string& PailNProof::y_n_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailNProof.y_N_arr)
  return _internal_y_n_arr(index);
}
inline std::string* PailNProof::mutable_y_n_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailNProof.y_N_arr)
  return y_n_arr_.Mutable(index);
}
inline void PailNProof::set_y_n_arr(int index, const std::string& value) {
  y_n_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailNProof.y_N_arr)
}
inline void PailNProof::set_y_n_arr(int index, std::string&& value) {
  y_n_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.PailNProof.y_N_arr)
}
inline void PailNProof::set_y_n_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_n_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailNProof.y_N_arr)
}
inline void PailNProof::set_y_n_arr(int index, const char* value, size_t size) {
  y_n_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailNProof.y_N_arr)
}
inline std::string* PailNProof::_internal_add_y_n_arr() {
  return y_n_arr_.Add();
}
inline void PailNProof::add_y_n_arr(const std::string& value) {
  y_n_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailNProof.y_N_arr)
}
inline void PailNProof::add_y_n_arr(std::string&& value) {
  y_n_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailNProof.y_N_arr)
}
inline void PailNProof::add_y_n_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_n_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailNProof.y_N_arr)
}
inline void PailNProof::add_y_n_arr(const char* value, size_t size) {
  y_n_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailNProof.y_N_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailNProof::y_n_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailNProof.y_N_arr)
  return y_n_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailNProof::mutable_y_n_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailNProof.y_N_arr)
  return &y_n_arr_;
}

// -------------------------------------------------------------------

// AliceRangeProof

// string z = 1;
inline void AliceRangeProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliceRangeProof::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.z)
}
inline std::string* AliceRangeProof::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.z)
  return _s;
}
inline const std::string& AliceRangeProof::_internal_z() const {
  return z_.Get();
}
inline void AliceRangeProof::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* AliceRangeProof::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* AliceRangeProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.z)
  return z_.Release();
}
inline void AliceRangeProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.z)
}

// string u = 2;
inline void AliceRangeProof::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliceRangeProof::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.u)
}
inline std::string* AliceRangeProof::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.u)
  return _s;
}
inline const std::string& AliceRangeProof::_internal_u() const {
  return u_.Get();
}
inline void AliceRangeProof::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* AliceRangeProof::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* AliceRangeProof::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.u)
  return u_.Release();
}
inline void AliceRangeProof::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.u)
}

// string w = 3;
inline void AliceRangeProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliceRangeProof::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.w)
}
inline std::string* AliceRangeProof::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.w)
  return _s;
}
inline const std::string& AliceRangeProof::_internal_w() const {
  return w_.Get();
}
inline void AliceRangeProof::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* AliceRangeProof::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* AliceRangeProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.w)
  return w_.Release();
}
inline void AliceRangeProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.w)
}

// string s = 4;
inline void AliceRangeProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliceRangeProof::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.s)
}
inline std::string* AliceRangeProof::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.s)
  return _s;
}
inline const std::string& AliceRangeProof::_internal_s() const {
  return s_.Get();
}
inline void AliceRangeProof::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* AliceRangeProof::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* AliceRangeProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.s)
  return s_.Release();
}
inline void AliceRangeProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.s)
}

// string s1 = 5;
inline void AliceRangeProof::clear_s1() {
  s1_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::s1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.s1)
  return _internal_s1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliceRangeProof::set_s1(ArgT0&& arg0, ArgT... args) {
 
 s1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.s1)
}
inline std::string* AliceRangeProof::mutable_s1() {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.s1)
  return _s;
}
inline const std::string& AliceRangeProof::_internal_s1() const {
  return s1_.Get();
}
inline void AliceRangeProof::_internal_set_s1(const std::string& value) {
  
  s1_.Set(value, GetArenaForAllocation());
}
inline std::string* AliceRangeProof::_internal_mutable_s1() {
  
  return s1_.Mutable(GetArenaForAllocation());
}
inline std::string* AliceRangeProof::release_s1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.s1)
  return s1_.Release();
}
inline void AliceRangeProof::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    
  } else {
    
  }
  s1_.SetAllocated(s1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s1_.IsDefault()) {
    s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.s1)
}

// string s2 = 6;
inline void AliceRangeProof::clear_s2() {
  s2_.ClearToEmpty();
}
inline const std::string& AliceRangeProof::s2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.AliceRangeProof.s2)
  return _internal_s2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AliceRangeProof::set_s2(ArgT0&& arg0, ArgT... args) {
 
 s2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.AliceRangeProof.s2)
}
inline std::string* AliceRangeProof::mutable_s2() {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.AliceRangeProof.s2)
  return _s;
}
inline const std::string& AliceRangeProof::_internal_s2() const {
  return s2_.Get();
}
inline void AliceRangeProof::_internal_set_s2(const std::string& value) {
  
  s2_.Set(value, GetArenaForAllocation());
}
inline std::string* AliceRangeProof::_internal_mutable_s2() {
  
  return s2_.Mutable(GetArenaForAllocation());
}
inline std::string* AliceRangeProof::release_s2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.AliceRangeProof.s2)
  return s2_.Release();
}
inline void AliceRangeProof::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    
  } else {
    
  }
  s2_.SetAllocated(s2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s2_.IsDefault()) {
    s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.AliceRangeProof.s2)
}

// -------------------------------------------------------------------

// RingPedersenParamPub

// string N_tilde = 1;
inline void RingPedersenParamPub::clear_n_tilde() {
  n_tilde_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPub::n_tilde() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPub.N_tilde)
  return _internal_n_tilde();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPub::set_n_tilde(ArgT0&& arg0, ArgT... args) {
 
 n_tilde_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPub.N_tilde)
}
inline std::string* RingPedersenParamPub::mutable_n_tilde() {
  std::string* _s = _internal_mutable_n_tilde();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPub.N_tilde)
  return _s;
}
inline const std::string& RingPedersenParamPub::_internal_n_tilde() const {
  return n_tilde_.Get();
}
inline void RingPedersenParamPub::_internal_set_n_tilde(const std::string& value) {
  
  n_tilde_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPub::_internal_mutable_n_tilde() {
  
  return n_tilde_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPub::release_n_tilde() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPub.N_tilde)
  return n_tilde_.Release();
}
inline void RingPedersenParamPub::set_allocated_n_tilde(std::string* n_tilde) {
  if (n_tilde != nullptr) {
    
  } else {
    
  }
  n_tilde_.SetAllocated(n_tilde, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (n_tilde_.IsDefault()) {
    n_tilde_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPub.N_tilde)
}

// string h1 = 2;
inline void RingPedersenParamPub::clear_h1() {
  h1_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPub::h1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPub.h1)
  return _internal_h1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPub::set_h1(ArgT0&& arg0, ArgT... args) {
 
 h1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPub.h1)
}
inline std::string* RingPedersenParamPub::mutable_h1() {
  std::string* _s = _internal_mutable_h1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPub.h1)
  return _s;
}
inline const std::string& RingPedersenParamPub::_internal_h1() const {
  return h1_.Get();
}
inline void RingPedersenParamPub::_internal_set_h1(const std::string& value) {
  
  h1_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPub::_internal_mutable_h1() {
  
  return h1_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPub::release_h1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPub.h1)
  return h1_.Release();
}
inline void RingPedersenParamPub::set_allocated_h1(std::string* h1) {
  if (h1 != nullptr) {
    
  } else {
    
  }
  h1_.SetAllocated(h1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (h1_.IsDefault()) {
    h1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPub.h1)
}

// string h2 = 3;
inline void RingPedersenParamPub::clear_h2() {
  h2_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPub::h2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPub.h2)
  return _internal_h2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPub::set_h2(ArgT0&& arg0, ArgT... args) {
 
 h2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPub.h2)
}
inline std::string* RingPedersenParamPub::mutable_h2() {
  std::string* _s = _internal_mutable_h2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPub.h2)
  return _s;
}
inline const std::string& RingPedersenParamPub::_internal_h2() const {
  return h2_.Get();
}
inline void RingPedersenParamPub::_internal_set_h2(const std::string& value) {
  
  h2_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPub::_internal_mutable_h2() {
  
  return h2_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPub::release_h2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPub.h2)
  return h2_.Release();
}
inline void RingPedersenParamPub::set_allocated_h2(std::string* h2) {
  if (h2 != nullptr) {
    
  } else {
    
  }
  h2_.SetAllocated(h2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (h2_.IsDefault()) {
    h2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPub.h2)
}

// -------------------------------------------------------------------

// RingPedersenParamPriv

// string N_tilde = 1;
inline void RingPedersenParamPriv::clear_n_tilde() {
  n_tilde_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::n_tilde() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.N_tilde)
  return _internal_n_tilde();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_n_tilde(ArgT0&& arg0, ArgT... args) {
 
 n_tilde_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.N_tilde)
}
inline std::string* RingPedersenParamPriv::mutable_n_tilde() {
  std::string* _s = _internal_mutable_n_tilde();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.N_tilde)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_n_tilde() const {
  return n_tilde_.Get();
}
inline void RingPedersenParamPriv::_internal_set_n_tilde(const std::string& value) {
  
  n_tilde_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_n_tilde() {
  
  return n_tilde_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_n_tilde() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.N_tilde)
  return n_tilde_.Release();
}
inline void RingPedersenParamPriv::set_allocated_n_tilde(std::string* n_tilde) {
  if (n_tilde != nullptr) {
    
  } else {
    
  }
  n_tilde_.SetAllocated(n_tilde, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (n_tilde_.IsDefault()) {
    n_tilde_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.N_tilde)
}

// string p = 2;
inline void RingPedersenParamPriv::clear_p() {
  p_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::p() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.p)
  return _internal_p();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_p(ArgT0&& arg0, ArgT... args) {
 
 p_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.p)
}
inline std::string* RingPedersenParamPriv::mutable_p() {
  std::string* _s = _internal_mutable_p();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.p)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_p() const {
  return p_.Get();
}
inline void RingPedersenParamPriv::_internal_set_p(const std::string& value) {
  
  p_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_p() {
  
  return p_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_p() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.p)
  return p_.Release();
}
inline void RingPedersenParamPriv::set_allocated_p(std::string* p) {
  if (p != nullptr) {
    
  } else {
    
  }
  p_.SetAllocated(p, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (p_.IsDefault()) {
    p_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.p)
}

// string q = 3;
inline void RingPedersenParamPriv::clear_q() {
  q_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::q() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.q)
  return _internal_q();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_q(ArgT0&& arg0, ArgT... args) {
 
 q_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.q)
}
inline std::string* RingPedersenParamPriv::mutable_q() {
  std::string* _s = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.q)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_q() const {
  return q_.Get();
}
inline void RingPedersenParamPriv::_internal_set_q(const std::string& value) {
  
  q_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_q() {
  
  return q_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_q() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.q)
  return q_.Release();
}
inline void RingPedersenParamPriv::set_allocated_q(std::string* q) {
  if (q != nullptr) {
    
  } else {
    
  }
  q_.SetAllocated(q, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (q_.IsDefault()) {
    q_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.q)
}

// string h1 = 4;
inline void RingPedersenParamPriv::clear_h1() {
  h1_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::h1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.h1)
  return _internal_h1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_h1(ArgT0&& arg0, ArgT... args) {
 
 h1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.h1)
}
inline std::string* RingPedersenParamPriv::mutable_h1() {
  std::string* _s = _internal_mutable_h1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.h1)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_h1() const {
  return h1_.Get();
}
inline void RingPedersenParamPriv::_internal_set_h1(const std::string& value) {
  
  h1_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_h1() {
  
  return h1_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_h1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.h1)
  return h1_.Release();
}
inline void RingPedersenParamPriv::set_allocated_h1(std::string* h1) {
  if (h1 != nullptr) {
    
  } else {
    
  }
  h1_.SetAllocated(h1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (h1_.IsDefault()) {
    h1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.h1)
}

// string h2 = 5;
inline void RingPedersenParamPriv::clear_h2() {
  h2_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::h2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.h2)
  return _internal_h2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_h2(ArgT0&& arg0, ArgT... args) {
 
 h2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.h2)
}
inline std::string* RingPedersenParamPriv::mutable_h2() {
  std::string* _s = _internal_mutable_h2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.h2)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_h2() const {
  return h2_.Get();
}
inline void RingPedersenParamPriv::_internal_set_h2(const std::string& value) {
  
  h2_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_h2() {
  
  return h2_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_h2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.h2)
  return h2_.Release();
}
inline void RingPedersenParamPriv::set_allocated_h2(std::string* h2) {
  if (h2 != nullptr) {
    
  } else {
    
  }
  h2_.SetAllocated(h2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (h2_.IsDefault()) {
    h2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.h2)
}

// string alpha = 6;
inline void RingPedersenParamPriv::clear_alpha() {
  alpha_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::alpha() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.alpha)
  return _internal_alpha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_alpha(ArgT0&& arg0, ArgT... args) {
 
 alpha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.alpha)
}
inline std::string* RingPedersenParamPriv::mutable_alpha() {
  std::string* _s = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.alpha)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_alpha() const {
  return alpha_.Get();
}
inline void RingPedersenParamPriv::_internal_set_alpha(const std::string& value) {
  
  alpha_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_alpha() {
  
  return alpha_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_alpha() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.alpha)
  return alpha_.Release();
}
inline void RingPedersenParamPriv::set_allocated_alpha(std::string* alpha) {
  if (alpha != nullptr) {
    
  } else {
    
  }
  alpha_.SetAllocated(alpha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (alpha_.IsDefault()) {
    alpha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.alpha)
}

// string beta = 7;
inline void RingPedersenParamPriv::clear_beta() {
  beta_.ClearToEmpty();
}
inline const std::string& RingPedersenParamPriv::beta() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RingPedersenParamPriv.beta)
  return _internal_beta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RingPedersenParamPriv::set_beta(ArgT0&& arg0, ArgT... args) {
 
 beta_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.RingPedersenParamPriv.beta)
}
inline std::string* RingPedersenParamPriv::mutable_beta() {
  std::string* _s = _internal_mutable_beta();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RingPedersenParamPriv.beta)
  return _s;
}
inline const std::string& RingPedersenParamPriv::_internal_beta() const {
  return beta_.Get();
}
inline void RingPedersenParamPriv::_internal_set_beta(const std::string& value) {
  
  beta_.Set(value, GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::_internal_mutable_beta() {
  
  return beta_.Mutable(GetArenaForAllocation());
}
inline std::string* RingPedersenParamPriv::release_beta() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RingPedersenParamPriv.beta)
  return beta_.Release();
}
inline void RingPedersenParamPriv::set_allocated_beta(std::string* beta) {
  if (beta != nullptr) {
    
  } else {
    
  }
  beta_.SetAllocated(beta, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (beta_.IsDefault()) {
    beta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RingPedersenParamPriv.beta)
}

// -------------------------------------------------------------------

// DLNProof

// repeated string alpha_arr = 1;
inline int DLNProof::_internal_alpha_arr_size() const {
  return alpha_arr_.size();
}
inline int DLNProof::alpha_arr_size() const {
  return _internal_alpha_arr_size();
}
inline void DLNProof::clear_alpha_arr() {
  alpha_arr_.Clear();
}
inline std::string* DLNProof::add_alpha_arr() {
  std::string* _s = _internal_add_alpha_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.DLNProof.alpha_arr)
  return _s;
}
inline const std::string& DLNProof::_internal_alpha_arr(int index) const {
  return alpha_arr_.Get(index);
}
inline const std::string& DLNProof::alpha_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLNProof.alpha_arr)
  return _internal_alpha_arr(index);
}
inline std::string* DLNProof::mutable_alpha_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLNProof.alpha_arr)
  return alpha_arr_.Mutable(index);
}
inline void DLNProof::set_alpha_arr(int index, const std::string& value) {
  alpha_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::set_alpha_arr(int index, std::string&& value) {
  alpha_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::set_alpha_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alpha_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::set_alpha_arr(int index, const char* value, size_t size) {
  alpha_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.DLNProof.alpha_arr)
}
inline std::string* DLNProof::_internal_add_alpha_arr() {
  return alpha_arr_.Add();
}
inline void DLNProof::add_alpha_arr(const std::string& value) {
  alpha_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::add_alpha_arr(std::string&& value) {
  alpha_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::add_alpha_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  alpha_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.DLNProof.alpha_arr)
}
inline void DLNProof::add_alpha_arr(const char* value, size_t size) {
  alpha_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.DLNProof.alpha_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DLNProof::alpha_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.DLNProof.alpha_arr)
  return alpha_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DLNProof::mutable_alpha_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.DLNProof.alpha_arr)
  return &alpha_arr_;
}

// repeated string t_arr = 2;
inline int DLNProof::_internal_t_arr_size() const {
  return t_arr_.size();
}
inline int DLNProof::t_arr_size() const {
  return _internal_t_arr_size();
}
inline void DLNProof::clear_t_arr() {
  t_arr_.Clear();
}
inline std::string* DLNProof::add_t_arr() {
  std::string* _s = _internal_add_t_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.DLNProof.t_arr)
  return _s;
}
inline const std::string& DLNProof::_internal_t_arr(int index) const {
  return t_arr_.Get(index);
}
inline const std::string& DLNProof::t_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DLNProof.t_arr)
  return _internal_t_arr(index);
}
inline std::string* DLNProof::mutable_t_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DLNProof.t_arr)
  return t_arr_.Mutable(index);
}
inline void DLNProof::set_t_arr(int index, const std::string& value) {
  t_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::set_t_arr(int index, std::string&& value) {
  t_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::set_t_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  t_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::set_t_arr(int index, const char* value, size_t size) {
  t_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.DLNProof.t_arr)
}
inline std::string* DLNProof::_internal_add_t_arr() {
  return t_arr_.Add();
}
inline void DLNProof::add_t_arr(const std::string& value) {
  t_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::add_t_arr(std::string&& value) {
  t_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::add_t_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  t_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.DLNProof.t_arr)
}
inline void DLNProof::add_t_arr(const char* value, size_t size) {
  t_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.DLNProof.t_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DLNProof::t_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.DLNProof.t_arr)
  return t_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DLNProof::mutable_t_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.DLNProof.t_arr)
  return &t_arr_;
}

// -------------------------------------------------------------------

// TwoDLNProof

// .safeheron.proto.DLNProof dln_proof_1 = 1;
inline bool TwoDLNProof::_internal_has_dln_proof_1() const {
  return this != internal_default_instance() && dln_proof_1_ != nullptr;
}
inline bool TwoDLNProof::has_dln_proof_1() const {
  return _internal_has_dln_proof_1();
}
inline void TwoDLNProof::clear_dln_proof_1() {
  if (GetArenaForAllocation() == nullptr && dln_proof_1_ != nullptr) {
    delete dln_proof_1_;
  }
  dln_proof_1_ = nullptr;
}
inline const ::safeheron::proto::DLNProof& TwoDLNProof::_internal_dln_proof_1() const {
  const ::safeheron::proto::DLNProof* p = dln_proof_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::DLNProof&>(
      ::safeheron::proto::_DLNProof_default_instance_);
}
inline const ::safeheron::proto::DLNProof& TwoDLNProof::dln_proof_1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.TwoDLNProof.dln_proof_1)
  return _internal_dln_proof_1();
}
inline void TwoDLNProof::unsafe_arena_set_allocated_dln_proof_1(
    ::safeheron::proto::DLNProof* dln_proof_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dln_proof_1_);
  }
  dln_proof_1_ = dln_proof_1;
  if (dln_proof_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.TwoDLNProof.dln_proof_1)
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::release_dln_proof_1() {
  
  ::safeheron::proto::DLNProof* temp = dln_proof_1_;
  dln_proof_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::unsafe_arena_release_dln_proof_1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.TwoDLNProof.dln_proof_1)
  
  ::safeheron::proto::DLNProof* temp = dln_proof_1_;
  dln_proof_1_ = nullptr;
  return temp;
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::_internal_mutable_dln_proof_1() {
  
  if (dln_proof_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::DLNProof>(GetArenaForAllocation());
    dln_proof_1_ = p;
  }
  return dln_proof_1_;
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::mutable_dln_proof_1() {
  ::safeheron::proto::DLNProof* _msg = _internal_mutable_dln_proof_1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.TwoDLNProof.dln_proof_1)
  return _msg;
}
inline void TwoDLNProof::set_allocated_dln_proof_1(::safeheron::proto::DLNProof* dln_proof_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dln_proof_1_;
  }
  if (dln_proof_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dln_proof_1);
    if (message_arena != submessage_arena) {
      dln_proof_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dln_proof_1, submessage_arena);
    }
    
  } else {
    
  }
  dln_proof_1_ = dln_proof_1;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.TwoDLNProof.dln_proof_1)
}

// .safeheron.proto.DLNProof dln_proof_2 = 2;
inline bool TwoDLNProof::_internal_has_dln_proof_2() const {
  return this != internal_default_instance() && dln_proof_2_ != nullptr;
}
inline bool TwoDLNProof::has_dln_proof_2() const {
  return _internal_has_dln_proof_2();
}
inline void TwoDLNProof::clear_dln_proof_2() {
  if (GetArenaForAllocation() == nullptr && dln_proof_2_ != nullptr) {
    delete dln_proof_2_;
  }
  dln_proof_2_ = nullptr;
}
inline const ::safeheron::proto::DLNProof& TwoDLNProof::_internal_dln_proof_2() const {
  const ::safeheron::proto::DLNProof* p = dln_proof_2_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::DLNProof&>(
      ::safeheron::proto::_DLNProof_default_instance_);
}
inline const ::safeheron::proto::DLNProof& TwoDLNProof::dln_proof_2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.TwoDLNProof.dln_proof_2)
  return _internal_dln_proof_2();
}
inline void TwoDLNProof::unsafe_arena_set_allocated_dln_proof_2(
    ::safeheron::proto::DLNProof* dln_proof_2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dln_proof_2_);
  }
  dln_proof_2_ = dln_proof_2;
  if (dln_proof_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.TwoDLNProof.dln_proof_2)
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::release_dln_proof_2() {
  
  ::safeheron::proto::DLNProof* temp = dln_proof_2_;
  dln_proof_2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::unsafe_arena_release_dln_proof_2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.TwoDLNProof.dln_proof_2)
  
  ::safeheron::proto::DLNProof* temp = dln_proof_2_;
  dln_proof_2_ = nullptr;
  return temp;
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::_internal_mutable_dln_proof_2() {
  
  if (dln_proof_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::DLNProof>(GetArenaForAllocation());
    dln_proof_2_ = p;
  }
  return dln_proof_2_;
}
inline ::safeheron::proto::DLNProof* TwoDLNProof::mutable_dln_proof_2() {
  ::safeheron::proto::DLNProof* _msg = _internal_mutable_dln_proof_2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.TwoDLNProof.dln_proof_2)
  return _msg;
}
inline void TwoDLNProof::set_allocated_dln_proof_2(::safeheron::proto::DLNProof* dln_proof_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete dln_proof_2_;
  }
  if (dln_proof_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dln_proof_2);
    if (message_arena != submessage_arena) {
      dln_proof_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dln_proof_2, submessage_arena);
    }
    
  } else {
    
  }
  dln_proof_2_ = dln_proof_2;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.TwoDLNProof.dln_proof_2)
}

// -------------------------------------------------------------------

// PedersenProof

// .safeheron.proto.CurvePoint Alpha = 3;
inline bool PedersenProof::_internal_has_alpha() const {
  return this != internal_default_instance() && alpha_ != nullptr;
}
inline bool PedersenProof::has_alpha() const {
  return _internal_has_alpha();
}
inline const ::safeheron::proto::CurvePoint& PedersenProof::_internal_alpha() const {
  const ::safeheron::proto::CurvePoint* p = alpha_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PedersenProof::alpha() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PedersenProof.Alpha)
  return _internal_alpha();
}
inline void PedersenProof::unsafe_arena_set_allocated_alpha(
    ::safeheron::proto::CurvePoint* alpha) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  alpha_ = alpha;
  if (alpha) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PedersenProof.Alpha)
}
inline ::safeheron::proto::CurvePoint* PedersenProof::release_alpha() {
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PedersenProof::unsafe_arena_release_alpha() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PedersenProof.Alpha)
  
  ::safeheron::proto::CurvePoint* temp = alpha_;
  alpha_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PedersenProof::_internal_mutable_alpha() {
  
  if (alpha_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    alpha_ = p;
  }
  return alpha_;
}
inline ::safeheron::proto::CurvePoint* PedersenProof::mutable_alpha() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_alpha();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PedersenProof.Alpha)
  return _msg;
}
inline void PedersenProof::set_allocated_alpha(::safeheron::proto::CurvePoint* alpha) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha_);
  }
  if (alpha) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alpha));
    if (message_arena != submessage_arena) {
      alpha = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alpha, submessage_arena);
    }
    
  } else {
    
  }
  alpha_ = alpha;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PedersenProof.Alpha)
}

// string t = 4;
inline void PedersenProof::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& PedersenProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PedersenProof.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PedersenProof::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PedersenProof.t)
}
inline std::string* PedersenProof::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PedersenProof.t)
  return _s;
}
inline const std::string& PedersenProof::_internal_t() const {
  return t_.Get();
}
inline void PedersenProof::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* PedersenProof::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* PedersenProof::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PedersenProof.t)
  return t_.Release();
}
inline void PedersenProof::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PedersenProof.t)
}

// string u = 5;
inline void PedersenProof::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& PedersenProof::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PedersenProof.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PedersenProof::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PedersenProof.u)
}
inline std::string* PedersenProof::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PedersenProof.u)
  return _s;
}
inline const std::string& PedersenProof::_internal_u() const {
  return u_.Get();
}
inline void PedersenProof::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* PedersenProof::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* PedersenProof::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PedersenProof.u)
  return u_.Release();
}
inline void PedersenProof::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PedersenProof.u)
}

// -------------------------------------------------------------------

// PailEncRangeProof_V3_Z

// int32 j = 1;
inline void PailEncRangeProof_V3_Z::clear_j() {
  j_ = 0;
}
inline int32_t PailEncRangeProof_V3_Z::_internal_j() const {
  return j_;
}
inline int32_t PailEncRangeProof_V3_Z::j() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.j)
  return _internal_j();
}
inline void PailEncRangeProof_V3_Z::_internal_set_j(int32_t value) {
  
  j_ = value;
}
inline void PailEncRangeProof_V3_Z::set_j(int32_t value) {
  _internal_set_j(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.j)
}

// string masked_x = 2;
inline void PailEncRangeProof_V3_Z::clear_masked_x() {
  masked_x_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V3_Z::masked_x() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.masked_x)
  return _internal_masked_x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V3_Z::set_masked_x(ArgT0&& arg0, ArgT... args) {
 
 masked_x_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.masked_x)
}
inline std::string* PailEncRangeProof_V3_Z::mutable_masked_x() {
  std::string* _s = _internal_mutable_masked_x();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.Z.masked_x)
  return _s;
}
inline const std::string& PailEncRangeProof_V3_Z::_internal_masked_x() const {
  return masked_x_.Get();
}
inline void PailEncRangeProof_V3_Z::_internal_set_masked_x(const std::string& value) {
  
  masked_x_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::_internal_mutable_masked_x() {
  
  return masked_x_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::release_masked_x() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V3.Z.masked_x)
  return masked_x_.Release();
}
inline void PailEncRangeProof_V3_Z::set_allocated_masked_x(std::string* masked_x) {
  if (masked_x != nullptr) {
    
  } else {
    
  }
  masked_x_.SetAllocated(masked_x, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (masked_x_.IsDefault()) {
    masked_x_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V3.Z.masked_x)
}

// string masked_r = 3;
inline void PailEncRangeProof_V3_Z::clear_masked_r() {
  masked_r_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V3_Z::masked_r() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.masked_r)
  return _internal_masked_r();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V3_Z::set_masked_r(ArgT0&& arg0, ArgT... args) {
 
 masked_r_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.masked_r)
}
inline std::string* PailEncRangeProof_V3_Z::mutable_masked_r() {
  std::string* _s = _internal_mutable_masked_r();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.Z.masked_r)
  return _s;
}
inline const std::string& PailEncRangeProof_V3_Z::_internal_masked_r() const {
  return masked_r_.Get();
}
inline void PailEncRangeProof_V3_Z::_internal_set_masked_r(const std::string& value) {
  
  masked_r_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::_internal_mutable_masked_r() {
  
  return masked_r_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::release_masked_r() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V3.Z.masked_r)
  return masked_r_.Release();
}
inline void PailEncRangeProof_V3_Z::set_allocated_masked_r(std::string* masked_r) {
  if (masked_r != nullptr) {
    
  } else {
    
  }
  masked_r_.SetAllocated(masked_r, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (masked_r_.IsDefault()) {
    masked_r_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V3.Z.masked_r)
}

// string w1 = 4;
inline void PailEncRangeProof_V3_Z::clear_w1() {
  w1_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V3_Z::w1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.w1)
  return _internal_w1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V3_Z::set_w1(ArgT0&& arg0, ArgT... args) {
 
 w1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.w1)
}
inline std::string* PailEncRangeProof_V3_Z::mutable_w1() {
  std::string* _s = _internal_mutable_w1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.Z.w1)
  return _s;
}
inline const std::string& PailEncRangeProof_V3_Z::_internal_w1() const {
  return w1_.Get();
}
inline void PailEncRangeProof_V3_Z::_internal_set_w1(const std::string& value) {
  
  w1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::_internal_mutable_w1() {
  
  return w1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::release_w1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V3.Z.w1)
  return w1_.Release();
}
inline void PailEncRangeProof_V3_Z::set_allocated_w1(std::string* w1) {
  if (w1 != nullptr) {
    
  } else {
    
  }
  w1_.SetAllocated(w1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w1_.IsDefault()) {
    w1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V3.Z.w1)
}

// string w2 = 5;
inline void PailEncRangeProof_V3_Z::clear_w2() {
  w2_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V3_Z::w2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.w2)
  return _internal_w2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V3_Z::set_w2(ArgT0&& arg0, ArgT... args) {
 
 w2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.w2)
}
inline std::string* PailEncRangeProof_V3_Z::mutable_w2() {
  std::string* _s = _internal_mutable_w2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.Z.w2)
  return _s;
}
inline const std::string& PailEncRangeProof_V3_Z::_internal_w2() const {
  return w2_.Get();
}
inline void PailEncRangeProof_V3_Z::_internal_set_w2(const std::string& value) {
  
  w2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::_internal_mutable_w2() {
  
  return w2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::release_w2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V3.Z.w2)
  return w2_.Release();
}
inline void PailEncRangeProof_V3_Z::set_allocated_w2(std::string* w2) {
  if (w2 != nullptr) {
    
  } else {
    
  }
  w2_.SetAllocated(w2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w2_.IsDefault()) {
    w2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V3.Z.w2)
}

// string r1 = 6;
inline void PailEncRangeProof_V3_Z::clear_r1() {
  r1_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V3_Z::r1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.r1)
  return _internal_r1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V3_Z::set_r1(ArgT0&& arg0, ArgT... args) {
 
 r1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.r1)
}
inline std::string* PailEncRangeProof_V3_Z::mutable_r1() {
  std::string* _s = _internal_mutable_r1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.Z.r1)
  return _s;
}
inline const std::string& PailEncRangeProof_V3_Z::_internal_r1() const {
  return r1_.Get();
}
inline void PailEncRangeProof_V3_Z::_internal_set_r1(const std::string& value) {
  
  r1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::_internal_mutable_r1() {
  
  return r1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::release_r1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V3.Z.r1)
  return r1_.Release();
}
inline void PailEncRangeProof_V3_Z::set_allocated_r1(std::string* r1) {
  if (r1 != nullptr) {
    
  } else {
    
  }
  r1_.SetAllocated(r1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (r1_.IsDefault()) {
    r1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V3.Z.r1)
}

// string r2 = 7;
inline void PailEncRangeProof_V3_Z::clear_r2() {
  r2_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V3_Z::r2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.Z.r2)
  return _internal_r2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V3_Z::set_r2(ArgT0&& arg0, ArgT... args) {
 
 r2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.Z.r2)
}
inline std::string* PailEncRangeProof_V3_Z::mutable_r2() {
  std::string* _s = _internal_mutable_r2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.Z.r2)
  return _s;
}
inline const std::string& PailEncRangeProof_V3_Z::_internal_r2() const {
  return r2_.Get();
}
inline void PailEncRangeProof_V3_Z::_internal_set_r2(const std::string& value) {
  
  r2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::_internal_mutable_r2() {
  
  return r2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V3_Z::release_r2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V3.Z.r2)
  return r2_.Release();
}
inline void PailEncRangeProof_V3_Z::set_allocated_r2(std::string* r2) {
  if (r2 != nullptr) {
    
  } else {
    
  }
  r2_.SetAllocated(r2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (r2_.IsDefault()) {
    r2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V3.Z.r2)
}

// -------------------------------------------------------------------

// PailEncRangeProof_V3

// repeated string c1_arr = 1;
inline int PailEncRangeProof_V3::_internal_c1_arr_size() const {
  return c1_arr_.size();
}
inline int PailEncRangeProof_V3::c1_arr_size() const {
  return _internal_c1_arr_size();
}
inline void PailEncRangeProof_V3::clear_c1_arr() {
  c1_arr_.Clear();
}
inline std::string* PailEncRangeProof_V3::add_c1_arr() {
  std::string* _s = _internal_add_c1_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailEncRangeProof_V3.c1_arr)
  return _s;
}
inline const std::string& PailEncRangeProof_V3::_internal_c1_arr(int index) const {
  return c1_arr_.Get(index);
}
inline const std::string& PailEncRangeProof_V3::c1_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.c1_arr)
  return _internal_c1_arr(index);
}
inline std::string* PailEncRangeProof_V3::mutable_c1_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.c1_arr)
  return c1_arr_.Mutable(index);
}
inline void PailEncRangeProof_V3::set_c1_arr(int index, const std::string& value) {
  c1_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline void PailEncRangeProof_V3::set_c1_arr(int index, std::string&& value) {
  c1_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline void PailEncRangeProof_V3::set_c1_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  c1_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline void PailEncRangeProof_V3::set_c1_arr(int index, const char* value, size_t size) {
  c1_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline std::string* PailEncRangeProof_V3::_internal_add_c1_arr() {
  return c1_arr_.Add();
}
inline void PailEncRangeProof_V3::add_c1_arr(const std::string& value) {
  c1_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline void PailEncRangeProof_V3::add_c1_arr(std::string&& value) {
  c1_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline void PailEncRangeProof_V3::add_c1_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  c1_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline void PailEncRangeProof_V3::add_c1_arr(const char* value, size_t size) {
  c1_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailEncRangeProof_V3.c1_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailEncRangeProof_V3::c1_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailEncRangeProof_V3.c1_arr)
  return c1_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailEncRangeProof_V3::mutable_c1_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailEncRangeProof_V3.c1_arr)
  return &c1_arr_;
}

// repeated string c2_arr = 2;
inline int PailEncRangeProof_V3::_internal_c2_arr_size() const {
  return c2_arr_.size();
}
inline int PailEncRangeProof_V3::c2_arr_size() const {
  return _internal_c2_arr_size();
}
inline void PailEncRangeProof_V3::clear_c2_arr() {
  c2_arr_.Clear();
}
inline std::string* PailEncRangeProof_V3::add_c2_arr() {
  std::string* _s = _internal_add_c2_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailEncRangeProof_V3.c2_arr)
  return _s;
}
inline const std::string& PailEncRangeProof_V3::_internal_c2_arr(int index) const {
  return c2_arr_.Get(index);
}
inline const std::string& PailEncRangeProof_V3::c2_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.c2_arr)
  return _internal_c2_arr(index);
}
inline std::string* PailEncRangeProof_V3::mutable_c2_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.c2_arr)
  return c2_arr_.Mutable(index);
}
inline void PailEncRangeProof_V3::set_c2_arr(int index, const std::string& value) {
  c2_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline void PailEncRangeProof_V3::set_c2_arr(int index, std::string&& value) {
  c2_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline void PailEncRangeProof_V3::set_c2_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  c2_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline void PailEncRangeProof_V3::set_c2_arr(int index, const char* value, size_t size) {
  c2_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline std::string* PailEncRangeProof_V3::_internal_add_c2_arr() {
  return c2_arr_.Add();
}
inline void PailEncRangeProof_V3::add_c2_arr(const std::string& value) {
  c2_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline void PailEncRangeProof_V3::add_c2_arr(std::string&& value) {
  c2_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline void PailEncRangeProof_V3::add_c2_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  c2_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline void PailEncRangeProof_V3::add_c2_arr(const char* value, size_t size) {
  c2_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailEncRangeProof_V3.c2_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailEncRangeProof_V3::c2_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailEncRangeProof_V3.c2_arr)
  return c2_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailEncRangeProof_V3::mutable_c2_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailEncRangeProof_V3.c2_arr)
  return &c2_arr_;
}

// repeated .safeheron.proto.PailEncRangeProof_V3.Z z_arr = 3;
inline int PailEncRangeProof_V3::_internal_z_arr_size() const {
  return z_arr_.size();
}
inline int PailEncRangeProof_V3::z_arr_size() const {
  return _internal_z_arr_size();
}
inline void PailEncRangeProof_V3::clear_z_arr() {
  z_arr_.Clear();
}
inline ::safeheron::proto::PailEncRangeProof_V3_Z* PailEncRangeProof_V3::mutable_z_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V3.z_arr)
  return z_arr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safeheron::proto::PailEncRangeProof_V3_Z >*
PailEncRangeProof_V3::mutable_z_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailEncRangeProof_V3.z_arr)
  return &z_arr_;
}
inline const ::safeheron::proto::PailEncRangeProof_V3_Z& PailEncRangeProof_V3::_internal_z_arr(int index) const {
  return z_arr_.Get(index);
}
inline const ::safeheron::proto::PailEncRangeProof_V3_Z& PailEncRangeProof_V3::z_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V3.z_arr)
  return _internal_z_arr(index);
}
inline ::safeheron::proto::PailEncRangeProof_V3_Z* PailEncRangeProof_V3::_internal_add_z_arr() {
  return z_arr_.Add();
}
inline ::safeheron::proto::PailEncRangeProof_V3_Z* PailEncRangeProof_V3::add_z_arr() {
  ::safeheron::proto::PailEncRangeProof_V3_Z* _add = _internal_add_z_arr();
  // @@protoc_insertion_point(field_add:safeheron.proto.PailEncRangeProof_V3.z_arr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::safeheron::proto::PailEncRangeProof_V3_Z >&
PailEncRangeProof_V3::z_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailEncRangeProof_V3.z_arr)
  return z_arr_;
}

// -------------------------------------------------------------------

// PailEncRangeProof_V1

// string z = 1;
inline void PailEncRangeProof_V1::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V1::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V1.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V1::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V1.z)
}
inline std::string* PailEncRangeProof_V1::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V1.z)
  return _s;
}
inline const std::string& PailEncRangeProof_V1::_internal_z() const {
  return z_.Get();
}
inline void PailEncRangeProof_V1::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V1.z)
  return z_.Release();
}
inline void PailEncRangeProof_V1::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V1.z)
}

// string u = 2;
inline void PailEncRangeProof_V1::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V1::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V1.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V1::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V1.u)
}
inline std::string* PailEncRangeProof_V1::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V1.u)
  return _s;
}
inline const std::string& PailEncRangeProof_V1::_internal_u() const {
  return u_.Get();
}
inline void PailEncRangeProof_V1::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V1.u)
  return u_.Release();
}
inline void PailEncRangeProof_V1::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V1.u)
}

// string w = 3;
inline void PailEncRangeProof_V1::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V1::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V1.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V1::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V1.w)
}
inline std::string* PailEncRangeProof_V1::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V1.w)
  return _s;
}
inline const std::string& PailEncRangeProof_V1::_internal_w() const {
  return w_.Get();
}
inline void PailEncRangeProof_V1::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V1.w)
  return w_.Release();
}
inline void PailEncRangeProof_V1::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V1.w)
}

// string s = 4;
inline void PailEncRangeProof_V1::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V1::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V1.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V1::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V1.s)
}
inline std::string* PailEncRangeProof_V1::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V1.s)
  return _s;
}
inline const std::string& PailEncRangeProof_V1::_internal_s() const {
  return s_.Get();
}
inline void PailEncRangeProof_V1::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V1.s)
  return s_.Release();
}
inline void PailEncRangeProof_V1::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V1.s)
}

// string s1 = 5;
inline void PailEncRangeProof_V1::clear_s1() {
  s1_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V1::s1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V1.s1)
  return _internal_s1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V1::set_s1(ArgT0&& arg0, ArgT... args) {
 
 s1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V1.s1)
}
inline std::string* PailEncRangeProof_V1::mutable_s1() {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V1.s1)
  return _s;
}
inline const std::string& PailEncRangeProof_V1::_internal_s1() const {
  return s1_.Get();
}
inline void PailEncRangeProof_V1::_internal_set_s1(const std::string& value) {
  
  s1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::_internal_mutable_s1() {
  
  return s1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::release_s1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V1.s1)
  return s1_.Release();
}
inline void PailEncRangeProof_V1::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    
  } else {
    
  }
  s1_.SetAllocated(s1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s1_.IsDefault()) {
    s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V1.s1)
}

// string s2 = 6;
inline void PailEncRangeProof_V1::clear_s2() {
  s2_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V1::s2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V1.s2)
  return _internal_s2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V1::set_s2(ArgT0&& arg0, ArgT... args) {
 
 s2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V1.s2)
}
inline std::string* PailEncRangeProof_V1::mutable_s2() {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V1.s2)
  return _s;
}
inline const std::string& PailEncRangeProof_V1::_internal_s2() const {
  return s2_.Get();
}
inline void PailEncRangeProof_V1::_internal_set_s2(const std::string& value) {
  
  s2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::_internal_mutable_s2() {
  
  return s2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V1::release_s2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V1.s2)
  return s2_.Release();
}
inline void PailEncRangeProof_V1::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    
  } else {
    
  }
  s2_.SetAllocated(s2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s2_.IsDefault()) {
    s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V1.s2)
}

// -------------------------------------------------------------------

// PailEncRangeProof_V2

// string S = 1;
inline void PailEncRangeProof_V2::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V2::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V2.S)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V2::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V2.S)
}
inline std::string* PailEncRangeProof_V2::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V2.S)
  return _s;
}
inline const std::string& PailEncRangeProof_V2::_internal_s() const {
  return s_.Get();
}
inline void PailEncRangeProof_V2::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V2.S)
  return s_.Release();
}
inline void PailEncRangeProof_V2::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V2.S)
}

// string A = 2;
inline void PailEncRangeProof_V2::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V2::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V2.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V2::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V2.A)
}
inline std::string* PailEncRangeProof_V2::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V2.A)
  return _s;
}
inline const std::string& PailEncRangeProof_V2::_internal_a() const {
  return a_.Get();
}
inline void PailEncRangeProof_V2::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V2.A)
  return a_.Release();
}
inline void PailEncRangeProof_V2::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V2.A)
}

// string C = 3;
inline void PailEncRangeProof_V2::clear_c() {
  c_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V2::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V2.C)
  return _internal_c();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V2::set_c(ArgT0&& arg0, ArgT... args) {
 
 c_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V2.C)
}
inline std::string* PailEncRangeProof_V2::mutable_c() {
  std::string* _s = _internal_mutable_c();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V2.C)
  return _s;
}
inline const std::string& PailEncRangeProof_V2::_internal_c() const {
  return c_.Get();
}
inline void PailEncRangeProof_V2::_internal_set_c(const std::string& value) {
  
  c_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::_internal_mutable_c() {
  
  return c_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V2.C)
  return c_.Release();
}
inline void PailEncRangeProof_V2::set_allocated_c(std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocated(c, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (c_.IsDefault()) {
    c_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V2.C)
}

// string z1 = 4;
inline void PailEncRangeProof_V2::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V2::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V2.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V2::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V2.z1)
}
inline std::string* PailEncRangeProof_V2::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V2.z1)
  return _s;
}
inline const std::string& PailEncRangeProof_V2::_internal_z1() const {
  return z1_.Get();
}
inline void PailEncRangeProof_V2::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V2.z1)
  return z1_.Release();
}
inline void PailEncRangeProof_V2::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V2.z1)
}

// string z2 = 5;
inline void PailEncRangeProof_V2::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V2::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V2.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V2::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V2.z2)
}
inline std::string* PailEncRangeProof_V2::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V2.z2)
  return _s;
}
inline const std::string& PailEncRangeProof_V2::_internal_z2() const {
  return z2_.Get();
}
inline void PailEncRangeProof_V2::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V2.z2)
  return z2_.Release();
}
inline void PailEncRangeProof_V2::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V2.z2)
}

// string z3 = 6;
inline void PailEncRangeProof_V2::clear_z3() {
  z3_.ClearToEmpty();
}
inline const std::string& PailEncRangeProof_V2::z3() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncRangeProof_V2.z3)
  return _internal_z3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncRangeProof_V2::set_z3(ArgT0&& arg0, ArgT... args) {
 
 z3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncRangeProof_V2.z3)
}
inline std::string* PailEncRangeProof_V2::mutable_z3() {
  std::string* _s = _internal_mutable_z3();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncRangeProof_V2.z3)
  return _s;
}
inline const std::string& PailEncRangeProof_V2::_internal_z3() const {
  return z3_.Get();
}
inline void PailEncRangeProof_V2::_internal_set_z3(const std::string& value) {
  
  z3_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::_internal_mutable_z3() {
  
  return z3_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncRangeProof_V2::release_z3() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncRangeProof_V2.z3)
  return z3_.Release();
}
inline void PailEncRangeProof_V2::set_allocated_z3(std::string* z3) {
  if (z3 != nullptr) {
    
  } else {
    
  }
  z3_.SetAllocated(z3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z3_.IsDefault()) {
    z3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncRangeProof_V2.z3)
}

// -------------------------------------------------------------------

// PailEncGroupEleRangeProof

// string S = 1;
inline void PailEncGroupEleRangeProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailEncGroupEleRangeProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.S)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncGroupEleRangeProof::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncGroupEleRangeProof.S)
}
inline std::string* PailEncGroupEleRangeProof::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.S)
  return _s;
}
inline const std::string& PailEncGroupEleRangeProof::_internal_s() const {
  return s_.Get();
}
inline void PailEncGroupEleRangeProof::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.S)
  return s_.Release();
}
inline void PailEncGroupEleRangeProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.S)
}

// string A = 2;
inline void PailEncGroupEleRangeProof::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& PailEncGroupEleRangeProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncGroupEleRangeProof::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncGroupEleRangeProof.A)
}
inline std::string* PailEncGroupEleRangeProof::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.A)
  return _s;
}
inline const std::string& PailEncGroupEleRangeProof::_internal_a() const {
  return a_.Get();
}
inline void PailEncGroupEleRangeProof::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.A)
  return a_.Release();
}
inline void PailEncGroupEleRangeProof::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.A)
}

// .safeheron.proto.CurvePoint Y = 3;
inline bool PailEncGroupEleRangeProof::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool PailEncGroupEleRangeProof::has_y() const {
  return _internal_has_y();
}
inline const ::safeheron::proto::CurvePoint& PailEncGroupEleRangeProof::_internal_y() const {
  const ::safeheron::proto::CurvePoint* p = y_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PailEncGroupEleRangeProof::y() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.Y)
  return _internal_y();
}
inline void PailEncGroupEleRangeProof::unsafe_arena_set_allocated_y(
    ::safeheron::proto::CurvePoint* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.Y)
}
inline ::safeheron::proto::CurvePoint* PailEncGroupEleRangeProof::release_y() {
  
  ::safeheron::proto::CurvePoint* temp = y_;
  y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailEncGroupEleRangeProof::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.Y)
  
  ::safeheron::proto::CurvePoint* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailEncGroupEleRangeProof::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    y_ = p;
  }
  return y_;
}
inline ::safeheron::proto::CurvePoint* PailEncGroupEleRangeProof::mutable_y() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.Y)
  return _msg;
}
inline void PailEncGroupEleRangeProof::set_allocated_y(::safeheron::proto::CurvePoint* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y));
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.Y)
}

// string D = 4;
inline void PailEncGroupEleRangeProof::clear_d() {
  d_.ClearToEmpty();
}
inline const std::string& PailEncGroupEleRangeProof::d() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.D)
  return _internal_d();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncGroupEleRangeProof::set_d(ArgT0&& arg0, ArgT... args) {
 
 d_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncGroupEleRangeProof.D)
}
inline std::string* PailEncGroupEleRangeProof::mutable_d() {
  std::string* _s = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.D)
  return _s;
}
inline const std::string& PailEncGroupEleRangeProof::_internal_d() const {
  return d_.Get();
}
inline void PailEncGroupEleRangeProof::_internal_set_d(const std::string& value) {
  
  d_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::_internal_mutable_d() {
  
  return d_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::release_d() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.D)
  return d_.Release();
}
inline void PailEncGroupEleRangeProof::set_allocated_d(std::string* d) {
  if (d != nullptr) {
    
  } else {
    
  }
  d_.SetAllocated(d, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (d_.IsDefault()) {
    d_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.D)
}

// string z1 = 5;
inline void PailEncGroupEleRangeProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& PailEncGroupEleRangeProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncGroupEleRangeProof::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncGroupEleRangeProof.z1)
}
inline std::string* PailEncGroupEleRangeProof::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.z1)
  return _s;
}
inline const std::string& PailEncGroupEleRangeProof::_internal_z1() const {
  return z1_.Get();
}
inline void PailEncGroupEleRangeProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.z1)
  return z1_.Release();
}
inline void PailEncGroupEleRangeProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.z1)
}

// string z2 = 6;
inline void PailEncGroupEleRangeProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& PailEncGroupEleRangeProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncGroupEleRangeProof::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncGroupEleRangeProof.z2)
}
inline std::string* PailEncGroupEleRangeProof::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.z2)
  return _s;
}
inline const std::string& PailEncGroupEleRangeProof::_internal_z2() const {
  return z2_.Get();
}
inline void PailEncGroupEleRangeProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.z2)
  return z2_.Release();
}
inline void PailEncGroupEleRangeProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.z2)
}

// string z3 = 7;
inline void PailEncGroupEleRangeProof::clear_z3() {
  z3_.ClearToEmpty();
}
inline const std::string& PailEncGroupEleRangeProof::z3() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncGroupEleRangeProof.z3)
  return _internal_z3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncGroupEleRangeProof::set_z3(ArgT0&& arg0, ArgT... args) {
 
 z3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncGroupEleRangeProof.z3)
}
inline std::string* PailEncGroupEleRangeProof::mutable_z3() {
  std::string* _s = _internal_mutable_z3();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncGroupEleRangeProof.z3)
  return _s;
}
inline const std::string& PailEncGroupEleRangeProof::_internal_z3() const {
  return z3_.Get();
}
inline void PailEncGroupEleRangeProof::_internal_set_z3(const std::string& value) {
  
  z3_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::_internal_mutable_z3() {
  
  return z3_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncGroupEleRangeProof::release_z3() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncGroupEleRangeProof.z3)
  return z3_.Release();
}
inline void PailEncGroupEleRangeProof::set_allocated_z3(std::string* z3) {
  if (z3 != nullptr) {
    
  } else {
    
  }
  z3_.SetAllocated(z3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z3_.IsDefault()) {
    z3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncGroupEleRangeProof.z3)
}

// -------------------------------------------------------------------

// PailAffRangeProof

// string z = 2;
inline void PailAffRangeProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.z)
}
inline std::string* PailAffRangeProof::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.z)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_z() const {
  return z_.Get();
}
inline void PailAffRangeProof::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.z)
  return z_.Release();
}
inline void PailAffRangeProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.z)
}

// string z_prime = 3;
inline void PailAffRangeProof::clear_z_prime() {
  z_prime_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::z_prime() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.z_prime)
  return _internal_z_prime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_z_prime(ArgT0&& arg0, ArgT... args) {
 
 z_prime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.z_prime)
}
inline std::string* PailAffRangeProof::mutable_z_prime() {
  std::string* _s = _internal_mutable_z_prime();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.z_prime)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_z_prime() const {
  return z_prime_.Get();
}
inline void PailAffRangeProof::_internal_set_z_prime(const std::string& value) {
  
  z_prime_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_z_prime() {
  
  return z_prime_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_z_prime() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.z_prime)
  return z_prime_.Release();
}
inline void PailAffRangeProof::set_allocated_z_prime(std::string* z_prime) {
  if (z_prime != nullptr) {
    
  } else {
    
  }
  z_prime_.SetAllocated(z_prime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_prime_.IsDefault()) {
    z_prime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.z_prime)
}

// string t = 4;
inline void PailAffRangeProof::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.t)
}
inline std::string* PailAffRangeProof::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.t)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_t() const {
  return t_.Get();
}
inline void PailAffRangeProof::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.t)
  return t_.Release();
}
inline void PailAffRangeProof::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.t)
}

// string v = 5;
inline void PailAffRangeProof::clear_v() {
  v_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::v() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_v(ArgT0&& arg0, ArgT... args) {
 
 v_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.v)
}
inline std::string* PailAffRangeProof::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.v)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_v() const {
  return v_.Get();
}
inline void PailAffRangeProof::_internal_set_v(const std::string& value) {
  
  v_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_v() {
  
  return v_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_v() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.v)
  return v_.Release();
}
inline void PailAffRangeProof::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (v_.IsDefault()) {
    v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.v)
}

// string w = 6;
inline void PailAffRangeProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.w)
}
inline std::string* PailAffRangeProof::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.w)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_w() const {
  return w_.Get();
}
inline void PailAffRangeProof::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.w)
  return w_.Release();
}
inline void PailAffRangeProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.w)
}

// string s = 7;
inline void PailAffRangeProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.s)
}
inline std::string* PailAffRangeProof::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.s)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_s() const {
  return s_.Get();
}
inline void PailAffRangeProof::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.s)
  return s_.Release();
}
inline void PailAffRangeProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.s)
}

// string s1 = 8;
inline void PailAffRangeProof::clear_s1() {
  s1_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::s1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.s1)
  return _internal_s1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_s1(ArgT0&& arg0, ArgT... args) {
 
 s1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.s1)
}
inline std::string* PailAffRangeProof::mutable_s1() {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.s1)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_s1() const {
  return s1_.Get();
}
inline void PailAffRangeProof::_internal_set_s1(const std::string& value) {
  
  s1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_s1() {
  
  return s1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_s1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.s1)
  return s1_.Release();
}
inline void PailAffRangeProof::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    
  } else {
    
  }
  s1_.SetAllocated(s1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s1_.IsDefault()) {
    s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.s1)
}

// string s2 = 9;
inline void PailAffRangeProof::clear_s2() {
  s2_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::s2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.s2)
  return _internal_s2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_s2(ArgT0&& arg0, ArgT... args) {
 
 s2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.s2)
}
inline std::string* PailAffRangeProof::mutable_s2() {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.s2)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_s2() const {
  return s2_.Get();
}
inline void PailAffRangeProof::_internal_set_s2(const std::string& value) {
  
  s2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_s2() {
  
  return s2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_s2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.s2)
  return s2_.Release();
}
inline void PailAffRangeProof::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    
  } else {
    
  }
  s2_.SetAllocated(s2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s2_.IsDefault()) {
    s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.s2)
}

// string t1 = 10;
inline void PailAffRangeProof::clear_t1() {
  t1_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::t1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.t1)
  return _internal_t1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_t1(ArgT0&& arg0, ArgT... args) {
 
 t1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.t1)
}
inline std::string* PailAffRangeProof::mutable_t1() {
  std::string* _s = _internal_mutable_t1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.t1)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_t1() const {
  return t1_.Get();
}
inline void PailAffRangeProof::_internal_set_t1(const std::string& value) {
  
  t1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_t1() {
  
  return t1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_t1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.t1)
  return t1_.Release();
}
inline void PailAffRangeProof::set_allocated_t1(std::string* t1) {
  if (t1 != nullptr) {
    
  } else {
    
  }
  t1_.SetAllocated(t1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t1_.IsDefault()) {
    t1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.t1)
}

// string t2 = 11;
inline void PailAffRangeProof::clear_t2() {
  t2_.ClearToEmpty();
}
inline const std::string& PailAffRangeProof::t2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffRangeProof.t2)
  return _internal_t2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffRangeProof::set_t2(ArgT0&& arg0, ArgT... args) {
 
 t2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffRangeProof.t2)
}
inline std::string* PailAffRangeProof::mutable_t2() {
  std::string* _s = _internal_mutable_t2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffRangeProof.t2)
  return _s;
}
inline const std::string& PailAffRangeProof::_internal_t2() const {
  return t2_.Get();
}
inline void PailAffRangeProof::_internal_set_t2(const std::string& value) {
  
  t2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::_internal_mutable_t2() {
  
  return t2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffRangeProof::release_t2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffRangeProof.t2)
  return t2_.Release();
}
inline void PailAffRangeProof::set_allocated_t2(std::string* t2) {
  if (t2 != nullptr) {
    
  } else {
    
  }
  t2_.SetAllocated(t2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t2_.IsDefault()) {
    t2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffRangeProof.t2)
}

// -------------------------------------------------------------------

// PailAffGroupEleRangeProof_V1

// .safeheron.proto.CurvePoint u = 1;
inline bool PailAffGroupEleRangeProof_V1::_internal_has_u() const {
  return this != internal_default_instance() && u_ != nullptr;
}
inline bool PailAffGroupEleRangeProof_V1::has_u() const {
  return _internal_has_u();
}
inline const ::safeheron::proto::CurvePoint& PailAffGroupEleRangeProof_V1::_internal_u() const {
  const ::safeheron::proto::CurvePoint* p = u_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PailAffGroupEleRangeProof_V1::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.u)
  return _internal_u();
}
inline void PailAffGroupEleRangeProof_V1::unsafe_arena_set_allocated_u(
    ::safeheron::proto::CurvePoint* u) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(u_);
  }
  u_ = u;
  if (u) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.u)
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V1::release_u() {
  
  ::safeheron::proto::CurvePoint* temp = u_;
  u_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V1::unsafe_arena_release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.u)
  
  ::safeheron::proto::CurvePoint* temp = u_;
  u_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V1::_internal_mutable_u() {
  
  if (u_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    u_ = p;
  }
  return u_;
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V1::mutable_u() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.u)
  return _msg;
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_u(::safeheron::proto::CurvePoint* u) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(u_);
  }
  if (u) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(u));
    if (message_arena != submessage_arena) {
      u = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, u, submessage_arena);
    }
    
  } else {
    
  }
  u_ = u;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.u)
}

// string z = 2;
inline void PailAffGroupEleRangeProof_V1::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.z)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.z)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_z() const {
  return z_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.z)
  return z_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.z)
}

// string z_prime = 3;
inline void PailAffGroupEleRangeProof_V1::clear_z_prime() {
  z_prime_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::z_prime() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.z_prime)
  return _internal_z_prime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_z_prime(ArgT0&& arg0, ArgT... args) {
 
 z_prime_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.z_prime)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_z_prime() {
  std::string* _s = _internal_mutable_z_prime();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.z_prime)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_z_prime() const {
  return z_prime_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_z_prime(const std::string& value) {
  
  z_prime_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_z_prime() {
  
  return z_prime_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_z_prime() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.z_prime)
  return z_prime_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_z_prime(std::string* z_prime) {
  if (z_prime != nullptr) {
    
  } else {
    
  }
  z_prime_.SetAllocated(z_prime, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_prime_.IsDefault()) {
    z_prime_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.z_prime)
}

// string t = 4;
inline void PailAffGroupEleRangeProof_V1::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.t)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.t)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.t)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_t() const {
  return t_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.t)
  return t_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.t)
}

// string v = 5;
inline void PailAffGroupEleRangeProof_V1::clear_v() {
  v_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::v() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_v(ArgT0&& arg0, ArgT... args) {
 
 v_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.v)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.v)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_v() const {
  return v_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_v(const std::string& value) {
  
  v_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_v() {
  
  return v_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_v() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.v)
  return v_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (v_.IsDefault()) {
    v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.v)
}

// string w = 6;
inline void PailAffGroupEleRangeProof_V1::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.w)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.w)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_w() const {
  return w_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.w)
  return w_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.w)
}

// string s = 7;
inline void PailAffGroupEleRangeProof_V1::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.s)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.s)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_s() const {
  return s_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.s)
  return s_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.s)
}

// string s1 = 8;
inline void PailAffGroupEleRangeProof_V1::clear_s1() {
  s1_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::s1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.s1)
  return _internal_s1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_s1(ArgT0&& arg0, ArgT... args) {
 
 s1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.s1)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_s1() {
  std::string* _s = _internal_mutable_s1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.s1)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_s1() const {
  return s1_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_s1(const std::string& value) {
  
  s1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_s1() {
  
  return s1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_s1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.s1)
  return s1_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_s1(std::string* s1) {
  if (s1 != nullptr) {
    
  } else {
    
  }
  s1_.SetAllocated(s1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s1_.IsDefault()) {
    s1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.s1)
}

// string s2 = 9;
inline void PailAffGroupEleRangeProof_V1::clear_s2() {
  s2_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::s2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.s2)
  return _internal_s2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_s2(ArgT0&& arg0, ArgT... args) {
 
 s2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.s2)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_s2() {
  std::string* _s = _internal_mutable_s2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.s2)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_s2() const {
  return s2_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_s2(const std::string& value) {
  
  s2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_s2() {
  
  return s2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_s2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.s2)
  return s2_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_s2(std::string* s2) {
  if (s2 != nullptr) {
    
  } else {
    
  }
  s2_.SetAllocated(s2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s2_.IsDefault()) {
    s2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.s2)
}

// string t1 = 10;
inline void PailAffGroupEleRangeProof_V1::clear_t1() {
  t1_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::t1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.t1)
  return _internal_t1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_t1(ArgT0&& arg0, ArgT... args) {
 
 t1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.t1)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_t1() {
  std::string* _s = _internal_mutable_t1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.t1)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_t1() const {
  return t1_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_t1(const std::string& value) {
  
  t1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_t1() {
  
  return t1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_t1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.t1)
  return t1_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_t1(std::string* t1) {
  if (t1 != nullptr) {
    
  } else {
    
  }
  t1_.SetAllocated(t1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t1_.IsDefault()) {
    t1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.t1)
}

// string t2 = 11;
inline void PailAffGroupEleRangeProof_V1::clear_t2() {
  t2_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V1::t2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V1.t2)
  return _internal_t2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V1::set_t2(ArgT0&& arg0, ArgT... args) {
 
 t2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V1.t2)
}
inline std::string* PailAffGroupEleRangeProof_V1::mutable_t2() {
  std::string* _s = _internal_mutable_t2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V1.t2)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V1::_internal_t2() const {
  return t2_.Get();
}
inline void PailAffGroupEleRangeProof_V1::_internal_set_t2(const std::string& value) {
  
  t2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::_internal_mutable_t2() {
  
  return t2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V1::release_t2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V1.t2)
  return t2_.Release();
}
inline void PailAffGroupEleRangeProof_V1::set_allocated_t2(std::string* t2) {
  if (t2 != nullptr) {
    
  } else {
    
  }
  t2_.SetAllocated(t2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t2_.IsDefault()) {
    t2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V1.t2)
}

// -------------------------------------------------------------------

// PailAffGroupEleRangeProof_V2

// string S = 1;
inline void PailAffGroupEleRangeProof_V2::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.S)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.S)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.S)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_s() const {
  return s_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.S)
  return s_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.S)
}

// string T = 2;
inline void PailAffGroupEleRangeProof_V2::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.T)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.T)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.T)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_t() const {
  return t_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.T)
  return t_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.T)
}

// string A = 3;
inline void PailAffGroupEleRangeProof_V2::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.A)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.A)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_a() const {
  return a_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.A)
  return a_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.A)
}

// .safeheron.proto.CurvePoint Bx = 4;
inline bool PailAffGroupEleRangeProof_V2::_internal_has_bx() const {
  return this != internal_default_instance() && bx_ != nullptr;
}
inline bool PailAffGroupEleRangeProof_V2::has_bx() const {
  return _internal_has_bx();
}
inline const ::safeheron::proto::CurvePoint& PailAffGroupEleRangeProof_V2::_internal_bx() const {
  const ::safeheron::proto::CurvePoint* p = bx_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PailAffGroupEleRangeProof_V2::bx() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.Bx)
  return _internal_bx();
}
inline void PailAffGroupEleRangeProof_V2::unsafe_arena_set_allocated_bx(
    ::safeheron::proto::CurvePoint* bx) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bx_);
  }
  bx_ = bx;
  if (bx) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.Bx)
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V2::release_bx() {
  
  ::safeheron::proto::CurvePoint* temp = bx_;
  bx_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V2::unsafe_arena_release_bx() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.Bx)
  
  ::safeheron::proto::CurvePoint* temp = bx_;
  bx_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V2::_internal_mutable_bx() {
  
  if (bx_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    bx_ = p;
  }
  return bx_;
}
inline ::safeheron::proto::CurvePoint* PailAffGroupEleRangeProof_V2::mutable_bx() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_bx();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.Bx)
  return _msg;
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_bx(::safeheron::proto::CurvePoint* bx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bx_);
  }
  if (bx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bx));
    if (message_arena != submessage_arena) {
      bx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bx, submessage_arena);
    }
    
  } else {
    
  }
  bx_ = bx;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.Bx)
}

// string By = 5;
inline void PailAffGroupEleRangeProof_V2::clear_by() {
  by_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::by() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.By)
  return _internal_by();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_by(ArgT0&& arg0, ArgT... args) {
 
 by_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.By)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_by() {
  std::string* _s = _internal_mutable_by();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.By)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_by() const {
  return by_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_by(const std::string& value) {
  
  by_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_by() {
  
  return by_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_by() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.By)
  return by_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_by(std::string* by) {
  if (by != nullptr) {
    
  } else {
    
  }
  by_.SetAllocated(by, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (by_.IsDefault()) {
    by_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.By)
}

// string E = 6;
inline void PailAffGroupEleRangeProof_V2::clear_e() {
  e_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::e() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.E)
  return _internal_e();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_e(ArgT0&& arg0, ArgT... args) {
 
 e_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.E)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_e() {
  std::string* _s = _internal_mutable_e();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.E)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_e() const {
  return e_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_e(const std::string& value) {
  
  e_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_e() {
  
  return e_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_e() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.E)
  return e_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_e(std::string* e) {
  if (e != nullptr) {
    
  } else {
    
  }
  e_.SetAllocated(e, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e_.IsDefault()) {
    e_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.E)
}

// string F = 7;
inline void PailAffGroupEleRangeProof_V2::clear_f() {
  f_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::f() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.F)
  return _internal_f();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_f(ArgT0&& arg0, ArgT... args) {
 
 f_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.F)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_f() {
  std::string* _s = _internal_mutable_f();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.F)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_f() const {
  return f_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_f(const std::string& value) {
  
  f_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_f() {
  
  return f_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_f() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.F)
  return f_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_f(std::string* f) {
  if (f != nullptr) {
    
  } else {
    
  }
  f_.SetAllocated(f, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (f_.IsDefault()) {
    f_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.F)
}

// string z1 = 8;
inline void PailAffGroupEleRangeProof_V2::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.z1)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.z1)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_z1() const {
  return z1_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.z1)
  return z1_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.z1)
}

// string z2 = 9;
inline void PailAffGroupEleRangeProof_V2::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.z2)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.z2)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_z2() const {
  return z2_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.z2)
  return z2_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.z2)
}

// string z3 = 10;
inline void PailAffGroupEleRangeProof_V2::clear_z3() {
  z3_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::z3() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.z3)
  return _internal_z3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_z3(ArgT0&& arg0, ArgT... args) {
 
 z3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.z3)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_z3() {
  std::string* _s = _internal_mutable_z3();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.z3)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_z3() const {
  return z3_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_z3(const std::string& value) {
  
  z3_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_z3() {
  
  return z3_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_z3() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.z3)
  return z3_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_z3(std::string* z3) {
  if (z3 != nullptr) {
    
  } else {
    
  }
  z3_.SetAllocated(z3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z3_.IsDefault()) {
    z3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.z3)
}

// string z4 = 11;
inline void PailAffGroupEleRangeProof_V2::clear_z4() {
  z4_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::z4() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.z4)
  return _internal_z4();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_z4(ArgT0&& arg0, ArgT... args) {
 
 z4_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.z4)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_z4() {
  std::string* _s = _internal_mutable_z4();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.z4)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_z4() const {
  return z4_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_z4(const std::string& value) {
  
  z4_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_z4() {
  
  return z4_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_z4() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.z4)
  return z4_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_z4(std::string* z4) {
  if (z4 != nullptr) {
    
  } else {
    
  }
  z4_.SetAllocated(z4, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z4_.IsDefault()) {
    z4_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.z4)
}

// string w = 12;
inline void PailAffGroupEleRangeProof_V2::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.w)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.w)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_w() const {
  return w_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.w)
  return w_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.w)
}

// string wy = 13;
inline void PailAffGroupEleRangeProof_V2::clear_wy() {
  wy_.ClearToEmpty();
}
inline const std::string& PailAffGroupEleRangeProof_V2::wy() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailAffGroupEleRangeProof_V2.wy)
  return _internal_wy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailAffGroupEleRangeProof_V2::set_wy(ArgT0&& arg0, ArgT... args) {
 
 wy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailAffGroupEleRangeProof_V2.wy)
}
inline std::string* PailAffGroupEleRangeProof_V2::mutable_wy() {
  std::string* _s = _internal_mutable_wy();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailAffGroupEleRangeProof_V2.wy)
  return _s;
}
inline const std::string& PailAffGroupEleRangeProof_V2::_internal_wy() const {
  return wy_.Get();
}
inline void PailAffGroupEleRangeProof_V2::_internal_set_wy(const std::string& value) {
  
  wy_.Set(value, GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::_internal_mutable_wy() {
  
  return wy_.Mutable(GetArenaForAllocation());
}
inline std::string* PailAffGroupEleRangeProof_V2::release_wy() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailAffGroupEleRangeProof_V2.wy)
  return wy_.Release();
}
inline void PailAffGroupEleRangeProof_V2::set_allocated_wy(std::string* wy) {
  if (wy != nullptr) {
    
  } else {
    
  }
  wy_.SetAllocated(wy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (wy_.IsDefault()) {
    wy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailAffGroupEleRangeProof_V2.wy)
}

// -------------------------------------------------------------------

// DlogEqualityProof

// .safeheron.proto.CurvePoint A = 1;
inline bool DlogEqualityProof::_internal_has_a() const {
  return this != internal_default_instance() && a_ != nullptr;
}
inline bool DlogEqualityProof::has_a() const {
  return _internal_has_a();
}
inline const ::safeheron::proto::CurvePoint& DlogEqualityProof::_internal_a() const {
  const ::safeheron::proto::CurvePoint* p = a_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DlogEqualityProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogEqualityProof.A)
  return _internal_a();
}
inline void DlogEqualityProof::unsafe_arena_set_allocated_a(
    ::safeheron::proto::CurvePoint* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  a_ = a;
  if (a) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DlogEqualityProof.A)
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::release_a() {
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogEqualityProof.A)
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::_internal_mutable_a() {
  
  if (a_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    a_ = p;
  }
  return a_;
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::mutable_a() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogEqualityProof.A)
  return _msg;
}
inline void DlogEqualityProof::set_allocated_a(::safeheron::proto::CurvePoint* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a));
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    
  } else {
    
  }
  a_ = a;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogEqualityProof.A)
}

// .safeheron.proto.CurvePoint B = 2;
inline bool DlogEqualityProof::_internal_has_b() const {
  return this != internal_default_instance() && b_ != nullptr;
}
inline bool DlogEqualityProof::has_b() const {
  return _internal_has_b();
}
inline const ::safeheron::proto::CurvePoint& DlogEqualityProof::_internal_b() const {
  const ::safeheron::proto::CurvePoint* p = b_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DlogEqualityProof::b() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogEqualityProof.B)
  return _internal_b();
}
inline void DlogEqualityProof::unsafe_arena_set_allocated_b(
    ::safeheron::proto::CurvePoint* b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(b_);
  }
  b_ = b;
  if (b) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DlogEqualityProof.B)
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::release_b() {
  
  ::safeheron::proto::CurvePoint* temp = b_;
  b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::unsafe_arena_release_b() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogEqualityProof.B)
  
  ::safeheron::proto::CurvePoint* temp = b_;
  b_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::_internal_mutable_b() {
  
  if (b_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    b_ = p;
  }
  return b_;
}
inline ::safeheron::proto::CurvePoint* DlogEqualityProof::mutable_b() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogEqualityProof.B)
  return _msg;
}
inline void DlogEqualityProof::set_allocated_b(::safeheron::proto::CurvePoint* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(b_);
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(b));
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    
  } else {
    
  }
  b_ = b;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogEqualityProof.B)
}

// string z = 3;
inline void DlogEqualityProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& DlogEqualityProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogEqualityProof.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DlogEqualityProof::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.DlogEqualityProof.z)
}
inline std::string* DlogEqualityProof::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogEqualityProof.z)
  return _s;
}
inline const std::string& DlogEqualityProof::_internal_z() const {
  return z_.Get();
}
inline void DlogEqualityProof::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* DlogEqualityProof::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* DlogEqualityProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogEqualityProof.z)
  return z_.Release();
}
inline void DlogEqualityProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogEqualityProof.z)
}

// -------------------------------------------------------------------

// DlogElGamalComProof

// .safeheron.proto.CurvePoint A = 1;
inline bool DlogElGamalComProof::_internal_has_a() const {
  return this != internal_default_instance() && a_ != nullptr;
}
inline bool DlogElGamalComProof::has_a() const {
  return _internal_has_a();
}
inline const ::safeheron::proto::CurvePoint& DlogElGamalComProof::_internal_a() const {
  const ::safeheron::proto::CurvePoint* p = a_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DlogElGamalComProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogElGamalComProof.A)
  return _internal_a();
}
inline void DlogElGamalComProof::unsafe_arena_set_allocated_a(
    ::safeheron::proto::CurvePoint* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  a_ = a;
  if (a) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DlogElGamalComProof.A)
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::release_a() {
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogElGamalComProof.A)
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::_internal_mutable_a() {
  
  if (a_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    a_ = p;
  }
  return a_;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::mutable_a() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogElGamalComProof.A)
  return _msg;
}
inline void DlogElGamalComProof::set_allocated_a(::safeheron::proto::CurvePoint* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a));
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    
  } else {
    
  }
  a_ = a;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogElGamalComProof.A)
}

// .safeheron.proto.CurvePoint N = 2;
inline bool DlogElGamalComProof::_internal_has_n() const {
  return this != internal_default_instance() && n_ != nullptr;
}
inline bool DlogElGamalComProof::has_n() const {
  return _internal_has_n();
}
inline const ::safeheron::proto::CurvePoint& DlogElGamalComProof::_internal_n() const {
  const ::safeheron::proto::CurvePoint* p = n_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DlogElGamalComProof::n() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogElGamalComProof.N)
  return _internal_n();
}
inline void DlogElGamalComProof::unsafe_arena_set_allocated_n(
    ::safeheron::proto::CurvePoint* n) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(n_);
  }
  n_ = n;
  if (n) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DlogElGamalComProof.N)
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::release_n() {
  
  ::safeheron::proto::CurvePoint* temp = n_;
  n_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::unsafe_arena_release_n() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogElGamalComProof.N)
  
  ::safeheron::proto::CurvePoint* temp = n_;
  n_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::_internal_mutable_n() {
  
  if (n_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    n_ = p;
  }
  return n_;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::mutable_n() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_n();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogElGamalComProof.N)
  return _msg;
}
inline void DlogElGamalComProof::set_allocated_n(::safeheron::proto::CurvePoint* n) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(n_);
  }
  if (n) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(n));
    if (message_arena != submessage_arena) {
      n = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, n, submessage_arena);
    }
    
  } else {
    
  }
  n_ = n;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogElGamalComProof.N)
}

// .safeheron.proto.CurvePoint B = 3;
inline bool DlogElGamalComProof::_internal_has_b() const {
  return this != internal_default_instance() && b_ != nullptr;
}
inline bool DlogElGamalComProof::has_b() const {
  return _internal_has_b();
}
inline const ::safeheron::proto::CurvePoint& DlogElGamalComProof::_internal_b() const {
  const ::safeheron::proto::CurvePoint* p = b_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& DlogElGamalComProof::b() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogElGamalComProof.B)
  return _internal_b();
}
inline void DlogElGamalComProof::unsafe_arena_set_allocated_b(
    ::safeheron::proto::CurvePoint* b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(b_);
  }
  b_ = b;
  if (b) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.DlogElGamalComProof.B)
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::release_b() {
  
  ::safeheron::proto::CurvePoint* temp = b_;
  b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::unsafe_arena_release_b() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogElGamalComProof.B)
  
  ::safeheron::proto::CurvePoint* temp = b_;
  b_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::_internal_mutable_b() {
  
  if (b_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    b_ = p;
  }
  return b_;
}
inline ::safeheron::proto::CurvePoint* DlogElGamalComProof::mutable_b() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogElGamalComProof.B)
  return _msg;
}
inline void DlogElGamalComProof::set_allocated_b(::safeheron::proto::CurvePoint* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(b_);
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(b));
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    
  } else {
    
  }
  b_ = b;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogElGamalComProof.B)
}

// string z = 4;
inline void DlogElGamalComProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& DlogElGamalComProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogElGamalComProof.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DlogElGamalComProof::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.DlogElGamalComProof.z)
}
inline std::string* DlogElGamalComProof::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogElGamalComProof.z)
  return _s;
}
inline const std::string& DlogElGamalComProof::_internal_z() const {
  return z_.Get();
}
inline void DlogElGamalComProof::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* DlogElGamalComProof::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* DlogElGamalComProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogElGamalComProof.z)
  return z_.Release();
}
inline void DlogElGamalComProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogElGamalComProof.z)
}

// string u = 5;
inline void DlogElGamalComProof::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& DlogElGamalComProof::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.DlogElGamalComProof.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DlogElGamalComProof::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.DlogElGamalComProof.u)
}
inline std::string* DlogElGamalComProof::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.DlogElGamalComProof.u)
  return _s;
}
inline const std::string& DlogElGamalComProof::_internal_u() const {
  return u_.Get();
}
inline void DlogElGamalComProof::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* DlogElGamalComProof::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* DlogElGamalComProof::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.DlogElGamalComProof.u)
  return u_.Release();
}
inline void DlogElGamalComProof::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.DlogElGamalComProof.u)
}

// -------------------------------------------------------------------

// PailEncElGamalComRangeProof

// string S = 1;
inline void PailEncElGamalComRangeProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.S)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.S)
}
inline std::string* PailEncElGamalComRangeProof::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.S)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_s() const {
  return s_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.S)
  return s_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.S)
}

// string D = 2;
inline void PailEncElGamalComRangeProof::clear_d() {
  d_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::d() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.D)
  return _internal_d();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_d(ArgT0&& arg0, ArgT... args) {
 
 d_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.D)
}
inline std::string* PailEncElGamalComRangeProof::mutable_d() {
  std::string* _s = _internal_mutable_d();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.D)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_d() const {
  return d_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_d(const std::string& value) {
  
  d_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_d() {
  
  return d_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_d() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.D)
  return d_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_d(std::string* d) {
  if (d != nullptr) {
    
  } else {
    
  }
  d_.SetAllocated(d, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (d_.IsDefault()) {
    d_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.D)
}

// .safeheron.proto.CurvePoint Y = 3;
inline bool PailEncElGamalComRangeProof::_internal_has_y() const {
  return this != internal_default_instance() && y_ != nullptr;
}
inline bool PailEncElGamalComRangeProof::has_y() const {
  return _internal_has_y();
}
inline const ::safeheron::proto::CurvePoint& PailEncElGamalComRangeProof::_internal_y() const {
  const ::safeheron::proto::CurvePoint* p = y_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PailEncElGamalComRangeProof::y() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.Y)
  return _internal_y();
}
inline void PailEncElGamalComRangeProof::unsafe_arena_set_allocated_y(
    ::safeheron::proto::CurvePoint* y) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.Y)
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::release_y() {
  
  ::safeheron::proto::CurvePoint* temp = y_;
  y_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.Y)
  
  ::safeheron::proto::CurvePoint* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::_internal_mutable_y() {
  
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    y_ = p;
  }
  return y_;
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::mutable_y() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_y();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.Y)
  return _msg;
}
inline void PailEncElGamalComRangeProof::set_allocated_y(::safeheron::proto::CurvePoint* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y));
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.Y)
}

// .safeheron.proto.CurvePoint Z = 4;
inline bool PailEncElGamalComRangeProof::_internal_has_z() const {
  return this != internal_default_instance() && z_ != nullptr;
}
inline bool PailEncElGamalComRangeProof::has_z() const {
  return _internal_has_z();
}
inline const ::safeheron::proto::CurvePoint& PailEncElGamalComRangeProof::_internal_z() const {
  const ::safeheron::proto::CurvePoint* p = z_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PailEncElGamalComRangeProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.Z)
  return _internal_z();
}
inline void PailEncElGamalComRangeProof::unsafe_arena_set_allocated_z(
    ::safeheron::proto::CurvePoint* z) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  z_ = z;
  if (z) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.Z)
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::release_z() {
  
  ::safeheron::proto::CurvePoint* temp = z_;
  z_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.Z)
  
  ::safeheron::proto::CurvePoint* temp = z_;
  z_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::_internal_mutable_z() {
  
  if (z_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    z_ = p;
  }
  return z_;
}
inline ::safeheron::proto::CurvePoint* PailEncElGamalComRangeProof::mutable_z() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.Z)
  return _msg;
}
inline void PailEncElGamalComRangeProof::set_allocated_z(::safeheron::proto::CurvePoint* z) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(z_);
  }
  if (z) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(z));
    if (message_arena != submessage_arena) {
      z = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.Z)
}

// string T = 5;
inline void PailEncElGamalComRangeProof::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.T)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.T)
}
inline std::string* PailEncElGamalComRangeProof::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.T)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_t() const {
  return t_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.T)
  return t_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.T)
}

// string z1 = 6;
inline void PailEncElGamalComRangeProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.z1)
}
inline std::string* PailEncElGamalComRangeProof::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.z1)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_z1() const {
  return z1_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.z1)
  return z1_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.z1)
}

// string w = 7;
inline void PailEncElGamalComRangeProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.w)
}
inline std::string* PailEncElGamalComRangeProof::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.w)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_w() const {
  return w_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.w)
  return w_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.w)
}

// string z2 = 8;
inline void PailEncElGamalComRangeProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.z2)
}
inline std::string* PailEncElGamalComRangeProof::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.z2)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_z2() const {
  return z2_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.z2)
  return z2_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.z2)
}

// string z3 = 9;
inline void PailEncElGamalComRangeProof::clear_z3() {
  z3_.ClearToEmpty();
}
inline const std::string& PailEncElGamalComRangeProof::z3() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncElGamalComRangeProof.z3)
  return _internal_z3();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncElGamalComRangeProof::set_z3(ArgT0&& arg0, ArgT... args) {
 
 z3_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncElGamalComRangeProof.z3)
}
inline std::string* PailEncElGamalComRangeProof::mutable_z3() {
  std::string* _s = _internal_mutable_z3();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncElGamalComRangeProof.z3)
  return _s;
}
inline const std::string& PailEncElGamalComRangeProof::_internal_z3() const {
  return z3_.Get();
}
inline void PailEncElGamalComRangeProof::_internal_set_z3(const std::string& value) {
  
  z3_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::_internal_mutable_z3() {
  
  return z3_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncElGamalComRangeProof::release_z3() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncElGamalComRangeProof.z3)
  return z3_.Release();
}
inline void PailEncElGamalComRangeProof::set_allocated_z3(std::string* z3) {
  if (z3 != nullptr) {
    
  } else {
    
  }
  z3_.SetAllocated(z3, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z3_.IsDefault()) {
    z3_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncElGamalComRangeProof.z3)
}

// -------------------------------------------------------------------

// NoSmallFactorProof

// string P = 1;
inline void NoSmallFactorProof::clear_p() {
  p_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::p() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.P)
  return _internal_p();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_p(ArgT0&& arg0, ArgT... args) {
 
 p_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.P)
}
inline std::string* NoSmallFactorProof::mutable_p() {
  std::string* _s = _internal_mutable_p();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.P)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_p() const {
  return p_.Get();
}
inline void NoSmallFactorProof::_internal_set_p(const std::string& value) {
  
  p_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_p() {
  
  return p_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_p() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.P)
  return p_.Release();
}
inline void NoSmallFactorProof::set_allocated_p(std::string* p) {
  if (p != nullptr) {
    
  } else {
    
  }
  p_.SetAllocated(p, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (p_.IsDefault()) {
    p_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.P)
}

// string Q = 2;
inline void NoSmallFactorProof::clear_q() {
  q_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::q() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.Q)
  return _internal_q();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_q(ArgT0&& arg0, ArgT... args) {
 
 q_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.Q)
}
inline std::string* NoSmallFactorProof::mutable_q() {
  std::string* _s = _internal_mutable_q();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.Q)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_q() const {
  return q_.Get();
}
inline void NoSmallFactorProof::_internal_set_q(const std::string& value) {
  
  q_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_q() {
  
  return q_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_q() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.Q)
  return q_.Release();
}
inline void NoSmallFactorProof::set_allocated_q(std::string* q) {
  if (q != nullptr) {
    
  } else {
    
  }
  q_.SetAllocated(q, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (q_.IsDefault()) {
    q_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.Q)
}

// string A = 3;
inline void NoSmallFactorProof::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.A)
}
inline std::string* NoSmallFactorProof::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.A)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_a() const {
  return a_.Get();
}
inline void NoSmallFactorProof::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.A)
  return a_.Release();
}
inline void NoSmallFactorProof::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.A)
}

// string B = 4;
inline void NoSmallFactorProof::clear_b() {
  b_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::b() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.B)
  return _internal_b();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_b(ArgT0&& arg0, ArgT... args) {
 
 b_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.B)
}
inline std::string* NoSmallFactorProof::mutable_b() {
  std::string* _s = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.B)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_b() const {
  return b_.Get();
}
inline void NoSmallFactorProof::_internal_set_b(const std::string& value) {
  
  b_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_b() {
  
  return b_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_b() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.B)
  return b_.Release();
}
inline void NoSmallFactorProof::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    
  } else {
    
  }
  b_.SetAllocated(b, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (b_.IsDefault()) {
    b_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.B)
}

// string T = 5;
inline void NoSmallFactorProof::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.T)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.T)
}
inline std::string* NoSmallFactorProof::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.T)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_t() const {
  return t_.Get();
}
inline void NoSmallFactorProof::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.T)
  return t_.Release();
}
inline void NoSmallFactorProof::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.T)
}

// string sigma = 6;
inline void NoSmallFactorProof::clear_sigma() {
  sigma_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::sigma() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.sigma)
  return _internal_sigma();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_sigma(ArgT0&& arg0, ArgT... args) {
 
 sigma_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.sigma)
}
inline std::string* NoSmallFactorProof::mutable_sigma() {
  std::string* _s = _internal_mutable_sigma();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.sigma)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_sigma() const {
  return sigma_.Get();
}
inline void NoSmallFactorProof::_internal_set_sigma(const std::string& value) {
  
  sigma_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_sigma() {
  
  return sigma_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_sigma() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.sigma)
  return sigma_.Release();
}
inline void NoSmallFactorProof::set_allocated_sigma(std::string* sigma) {
  if (sigma != nullptr) {
    
  } else {
    
  }
  sigma_.SetAllocated(sigma, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sigma_.IsDefault()) {
    sigma_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.sigma)
}

// string z1 = 7;
inline void NoSmallFactorProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.z1)
}
inline std::string* NoSmallFactorProof::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.z1)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_z1() const {
  return z1_.Get();
}
inline void NoSmallFactorProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.z1)
  return z1_.Release();
}
inline void NoSmallFactorProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.z1)
}

// string z2 = 8;
inline void NoSmallFactorProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.z2)
}
inline std::string* NoSmallFactorProof::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.z2)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_z2() const {
  return z2_.Get();
}
inline void NoSmallFactorProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.z2)
  return z2_.Release();
}
inline void NoSmallFactorProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.z2)
}

// string w1 = 9;
inline void NoSmallFactorProof::clear_w1() {
  w1_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::w1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.w1)
  return _internal_w1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_w1(ArgT0&& arg0, ArgT... args) {
 
 w1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.w1)
}
inline std::string* NoSmallFactorProof::mutable_w1() {
  std::string* _s = _internal_mutable_w1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.w1)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_w1() const {
  return w1_.Get();
}
inline void NoSmallFactorProof::_internal_set_w1(const std::string& value) {
  
  w1_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_w1() {
  
  return w1_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_w1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.w1)
  return w1_.Release();
}
inline void NoSmallFactorProof::set_allocated_w1(std::string* w1) {
  if (w1 != nullptr) {
    
  } else {
    
  }
  w1_.SetAllocated(w1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w1_.IsDefault()) {
    w1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.w1)
}

// string w2 = 10;
inline void NoSmallFactorProof::clear_w2() {
  w2_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::w2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.w2)
  return _internal_w2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_w2(ArgT0&& arg0, ArgT... args) {
 
 w2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.w2)
}
inline std::string* NoSmallFactorProof::mutable_w2() {
  std::string* _s = _internal_mutable_w2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.w2)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_w2() const {
  return w2_.Get();
}
inline void NoSmallFactorProof::_internal_set_w2(const std::string& value) {
  
  w2_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_w2() {
  
  return w2_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_w2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.w2)
  return w2_.Release();
}
inline void NoSmallFactorProof::set_allocated_w2(std::string* w2) {
  if (w2 != nullptr) {
    
  } else {
    
  }
  w2_.SetAllocated(w2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w2_.IsDefault()) {
    w2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.w2)
}

// string v = 11;
inline void NoSmallFactorProof::clear_v() {
  v_.ClearToEmpty();
}
inline const std::string& NoSmallFactorProof::v() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.NoSmallFactorProof.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NoSmallFactorProof::set_v(ArgT0&& arg0, ArgT... args) {
 
 v_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.NoSmallFactorProof.v)
}
inline std::string* NoSmallFactorProof::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.NoSmallFactorProof.v)
  return _s;
}
inline const std::string& NoSmallFactorProof::_internal_v() const {
  return v_.Get();
}
inline void NoSmallFactorProof::_internal_set_v(const std::string& value) {
  
  v_.Set(value, GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::_internal_mutable_v() {
  
  return v_.Mutable(GetArenaForAllocation());
}
inline std::string* NoSmallFactorProof::release_v() {
  // @@protoc_insertion_point(field_release:safeheron.proto.NoSmallFactorProof.v)
  return v_.Release();
}
inline void NoSmallFactorProof::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (v_.IsDefault()) {
    v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.NoSmallFactorProof.v)
}

// -------------------------------------------------------------------

// PailBlumModulusProof

// repeated string x_arr = 1;
inline int PailBlumModulusProof::_internal_x_arr_size() const {
  return x_arr_.size();
}
inline int PailBlumModulusProof::x_arr_size() const {
  return _internal_x_arr_size();
}
inline void PailBlumModulusProof::clear_x_arr() {
  x_arr_.Clear();
}
inline std::string* PailBlumModulusProof::add_x_arr() {
  std::string* _s = _internal_add_x_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailBlumModulusProof.x_arr)
  return _s;
}
inline const std::string& PailBlumModulusProof::_internal_x_arr(int index) const {
  return x_arr_.Get(index);
}
inline const std::string& PailBlumModulusProof::x_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailBlumModulusProof.x_arr)
  return _internal_x_arr(index);
}
inline std::string* PailBlumModulusProof::mutable_x_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailBlumModulusProof.x_arr)
  return x_arr_.Mutable(index);
}
inline void PailBlumModulusProof::set_x_arr(int index, const std::string& value) {
  x_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline void PailBlumModulusProof::set_x_arr(int index, std::string&& value) {
  x_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline void PailBlumModulusProof::set_x_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  x_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline void PailBlumModulusProof::set_x_arr(int index, const char* value, size_t size) {
  x_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline std::string* PailBlumModulusProof::_internal_add_x_arr() {
  return x_arr_.Add();
}
inline void PailBlumModulusProof::add_x_arr(const std::string& value) {
  x_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline void PailBlumModulusProof::add_x_arr(std::string&& value) {
  x_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline void PailBlumModulusProof::add_x_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  x_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline void PailBlumModulusProof::add_x_arr(const char* value, size_t size) {
  x_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailBlumModulusProof.x_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailBlumModulusProof::x_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailBlumModulusProof.x_arr)
  return x_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailBlumModulusProof::mutable_x_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailBlumModulusProof.x_arr)
  return &x_arr_;
}

// repeated int32 a_arr = 2;
inline int PailBlumModulusProof::_internal_a_arr_size() const {
  return a_arr_.size();
}
inline int PailBlumModulusProof::a_arr_size() const {
  return _internal_a_arr_size();
}
inline void PailBlumModulusProof::clear_a_arr() {
  a_arr_.Clear();
}
inline int32_t PailBlumModulusProof::_internal_a_arr(int index) const {
  return a_arr_.Get(index);
}
inline int32_t PailBlumModulusProof::a_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailBlumModulusProof.a_arr)
  return _internal_a_arr(index);
}
inline void PailBlumModulusProof::set_a_arr(int index, int32_t value) {
  a_arr_.Set(index, value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.a_arr)
}
inline void PailBlumModulusProof::_internal_add_a_arr(int32_t value) {
  a_arr_.Add(value);
}
inline void PailBlumModulusProof::add_a_arr(int32_t value) {
  _internal_add_a_arr(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailBlumModulusProof.a_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PailBlumModulusProof::_internal_a_arr() const {
  return a_arr_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PailBlumModulusProof::a_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailBlumModulusProof.a_arr)
  return _internal_a_arr();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PailBlumModulusProof::_internal_mutable_a_arr() {
  return &a_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PailBlumModulusProof::mutable_a_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailBlumModulusProof.a_arr)
  return _internal_mutable_a_arr();
}

// repeated int32 b_arr = 3;
inline int PailBlumModulusProof::_internal_b_arr_size() const {
  return b_arr_.size();
}
inline int PailBlumModulusProof::b_arr_size() const {
  return _internal_b_arr_size();
}
inline void PailBlumModulusProof::clear_b_arr() {
  b_arr_.Clear();
}
inline int32_t PailBlumModulusProof::_internal_b_arr(int index) const {
  return b_arr_.Get(index);
}
inline int32_t PailBlumModulusProof::b_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailBlumModulusProof.b_arr)
  return _internal_b_arr(index);
}
inline void PailBlumModulusProof::set_b_arr(int index, int32_t value) {
  b_arr_.Set(index, value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.b_arr)
}
inline void PailBlumModulusProof::_internal_add_b_arr(int32_t value) {
  b_arr_.Add(value);
}
inline void PailBlumModulusProof::add_b_arr(int32_t value) {
  _internal_add_b_arr(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailBlumModulusProof.b_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PailBlumModulusProof::_internal_b_arr() const {
  return b_arr_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
PailBlumModulusProof::b_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailBlumModulusProof.b_arr)
  return _internal_b_arr();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PailBlumModulusProof::_internal_mutable_b_arr() {
  return &b_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
PailBlumModulusProof::mutable_b_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailBlumModulusProof.b_arr)
  return _internal_mutable_b_arr();
}

// repeated string z_arr = 4;
inline int PailBlumModulusProof::_internal_z_arr_size() const {
  return z_arr_.size();
}
inline int PailBlumModulusProof::z_arr_size() const {
  return _internal_z_arr_size();
}
inline void PailBlumModulusProof::clear_z_arr() {
  z_arr_.Clear();
}
inline std::string* PailBlumModulusProof::add_z_arr() {
  std::string* _s = _internal_add_z_arr();
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.PailBlumModulusProof.z_arr)
  return _s;
}
inline const std::string& PailBlumModulusProof::_internal_z_arr(int index) const {
  return z_arr_.Get(index);
}
inline const std::string& PailBlumModulusProof::z_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailBlumModulusProof.z_arr)
  return _internal_z_arr(index);
}
inline std::string* PailBlumModulusProof::mutable_z_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailBlumModulusProof.z_arr)
  return z_arr_.Mutable(index);
}
inline void PailBlumModulusProof::set_z_arr(int index, const std::string& value) {
  z_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline void PailBlumModulusProof::set_z_arr(int index, std::string&& value) {
  z_arr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline void PailBlumModulusProof::set_z_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  z_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline void PailBlumModulusProof::set_z_arr(int index, const char* value, size_t size) {
  z_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline std::string* PailBlumModulusProof::_internal_add_z_arr() {
  return z_arr_.Add();
}
inline void PailBlumModulusProof::add_z_arr(const std::string& value) {
  z_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline void PailBlumModulusProof::add_z_arr(std::string&& value) {
  z_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline void PailBlumModulusProof::add_z_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  z_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline void PailBlumModulusProof::add_z_arr(const char* value, size_t size) {
  z_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.PailBlumModulusProof.z_arr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PailBlumModulusProof::z_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.PailBlumModulusProof.z_arr)
  return z_arr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PailBlumModulusProof::mutable_z_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.PailBlumModulusProof.z_arr)
  return &z_arr_;
}

// string w = 5;
inline void PailBlumModulusProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailBlumModulusProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailBlumModulusProof.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailBlumModulusProof::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailBlumModulusProof.w)
}
inline std::string* PailBlumModulusProof::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailBlumModulusProof.w)
  return _s;
}
inline const std::string& PailBlumModulusProof::_internal_w() const {
  return w_.Get();
}
inline void PailBlumModulusProof::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailBlumModulusProof::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailBlumModulusProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailBlumModulusProof.w)
  return w_.Release();
}
inline void PailBlumModulusProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailBlumModulusProof.w)
}

// -------------------------------------------------------------------

// PailDecModuloProof

// string S = 1;
inline void PailDecModuloProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.S)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.S)
}
inline std::string* PailDecModuloProof::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.S)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_s() const {
  return s_.Get();
}
inline void PailDecModuloProof::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.S)
  return s_.Release();
}
inline void PailDecModuloProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.S)
}

// string T = 2;
inline void PailDecModuloProof::clear_t() {
  t_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.T)
  return _internal_t();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_t(ArgT0&& arg0, ArgT... args) {
 
 t_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.T)
}
inline std::string* PailDecModuloProof::mutable_t() {
  std::string* _s = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.T)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_t() const {
  return t_.Get();
}
inline void PailDecModuloProof::_internal_set_t(const std::string& value) {
  
  t_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_t() {
  
  return t_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.T)
  return t_.Release();
}
inline void PailDecModuloProof::set_allocated_t(std::string* t) {
  if (t != nullptr) {
    
  } else {
    
  }
  t_.SetAllocated(t, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (t_.IsDefault()) {
    t_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.T)
}

// string A = 3;
inline void PailDecModuloProof::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.A)
}
inline std::string* PailDecModuloProof::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.A)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_a() const {
  return a_.Get();
}
inline void PailDecModuloProof::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.A)
  return a_.Release();
}
inline void PailDecModuloProof::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.A)
}

// string gamma = 4;
inline void PailDecModuloProof::clear_gamma() {
  gamma_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::gamma() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.gamma)
  return _internal_gamma();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_gamma(ArgT0&& arg0, ArgT... args) {
 
 gamma_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.gamma)
}
inline std::string* PailDecModuloProof::mutable_gamma() {
  std::string* _s = _internal_mutable_gamma();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.gamma)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_gamma() const {
  return gamma_.Get();
}
inline void PailDecModuloProof::_internal_set_gamma(const std::string& value) {
  
  gamma_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_gamma() {
  
  return gamma_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_gamma() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.gamma)
  return gamma_.Release();
}
inline void PailDecModuloProof::set_allocated_gamma(std::string* gamma) {
  if (gamma != nullptr) {
    
  } else {
    
  }
  gamma_.SetAllocated(gamma, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamma_.IsDefault()) {
    gamma_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.gamma)
}

// string z1 = 5;
inline void PailDecModuloProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.z1)
}
inline std::string* PailDecModuloProof::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.z1)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_z1() const {
  return z1_.Get();
}
inline void PailDecModuloProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.z1)
  return z1_.Release();
}
inline void PailDecModuloProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.z1)
}

// string z2 = 6;
inline void PailDecModuloProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.z2)
}
inline std::string* PailDecModuloProof::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.z2)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_z2() const {
  return z2_.Get();
}
inline void PailDecModuloProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.z2)
  return z2_.Release();
}
inline void PailDecModuloProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.z2)
}

// string w = 7;
inline void PailDecModuloProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailDecModuloProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailDecModuloProof.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailDecModuloProof::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailDecModuloProof.w)
}
inline std::string* PailDecModuloProof::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailDecModuloProof.w)
  return _s;
}
inline const std::string& PailDecModuloProof::_internal_w() const {
  return w_.Get();
}
inline void PailDecModuloProof::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailDecModuloProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailDecModuloProof.w)
  return w_.Release();
}
inline void PailDecModuloProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailDecModuloProof.w)
}

// -------------------------------------------------------------------

// PailEncMulProof

// string A = 1;
inline void PailEncMulProof::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& PailEncMulProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncMulProof.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncMulProof::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncMulProof.A)
}
inline std::string* PailEncMulProof::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncMulProof.A)
  return _s;
}
inline const std::string& PailEncMulProof::_internal_a() const {
  return a_.Get();
}
inline void PailEncMulProof::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncMulProof::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncMulProof::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncMulProof.A)
  return a_.Release();
}
inline void PailEncMulProof::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncMulProof.A)
}

// string B = 2;
inline void PailEncMulProof::clear_b() {
  b_.ClearToEmpty();
}
inline const std::string& PailEncMulProof::b() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncMulProof.B)
  return _internal_b();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncMulProof::set_b(ArgT0&& arg0, ArgT... args) {
 
 b_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncMulProof.B)
}
inline std::string* PailEncMulProof::mutable_b() {
  std::string* _s = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncMulProof.B)
  return _s;
}
inline const std::string& PailEncMulProof::_internal_b() const {
  return b_.Get();
}
inline void PailEncMulProof::_internal_set_b(const std::string& value) {
  
  b_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncMulProof::_internal_mutable_b() {
  
  return b_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncMulProof::release_b() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncMulProof.B)
  return b_.Release();
}
inline void PailEncMulProof::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    
  } else {
    
  }
  b_.SetAllocated(b, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (b_.IsDefault()) {
    b_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncMulProof.B)
}

// string z = 3;
inline void PailEncMulProof::clear_z() {
  z_.ClearToEmpty();
}
inline const std::string& PailEncMulProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncMulProof.z)
  return _internal_z();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncMulProof::set_z(ArgT0&& arg0, ArgT... args) {
 
 z_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncMulProof.z)
}
inline std::string* PailEncMulProof::mutable_z() {
  std::string* _s = _internal_mutable_z();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncMulProof.z)
  return _s;
}
inline const std::string& PailEncMulProof::_internal_z() const {
  return z_.Get();
}
inline void PailEncMulProof::_internal_set_z(const std::string& value) {
  
  z_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncMulProof::_internal_mutable_z() {
  
  return z_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncMulProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncMulProof.z)
  return z_.Release();
}
inline void PailEncMulProof::set_allocated_z(std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocated(z, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z_.IsDefault()) {
    z_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncMulProof.z)
}

// string u = 4;
inline void PailEncMulProof::clear_u() {
  u_.ClearToEmpty();
}
inline const std::string& PailEncMulProof::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncMulProof.u)
  return _internal_u();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncMulProof::set_u(ArgT0&& arg0, ArgT... args) {
 
 u_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncMulProof.u)
}
inline std::string* PailEncMulProof::mutable_u() {
  std::string* _s = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncMulProof.u)
  return _s;
}
inline const std::string& PailEncMulProof::_internal_u() const {
  return u_.Get();
}
inline void PailEncMulProof::_internal_set_u(const std::string& value) {
  
  u_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncMulProof::_internal_mutable_u() {
  
  return u_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncMulProof::release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncMulProof.u)
  return u_.Release();
}
inline void PailEncMulProof::set_allocated_u(std::string* u) {
  if (u != nullptr) {
    
  } else {
    
  }
  u_.SetAllocated(u, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (u_.IsDefault()) {
    u_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncMulProof.u)
}

// string v = 5;
inline void PailEncMulProof::clear_v() {
  v_.ClearToEmpty();
}
inline const std::string& PailEncMulProof::v() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailEncMulProof.v)
  return _internal_v();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailEncMulProof::set_v(ArgT0&& arg0, ArgT... args) {
 
 v_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailEncMulProof.v)
}
inline std::string* PailEncMulProof::mutable_v() {
  std::string* _s = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailEncMulProof.v)
  return _s;
}
inline const std::string& PailEncMulProof::_internal_v() const {
  return v_.Get();
}
inline void PailEncMulProof::_internal_set_v(const std::string& value) {
  
  v_.Set(value, GetArenaForAllocation());
}
inline std::string* PailEncMulProof::_internal_mutable_v() {
  
  return v_.Mutable(GetArenaForAllocation());
}
inline std::string* PailEncMulProof::release_v() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailEncMulProof.v)
  return v_.Release();
}
inline void PailEncMulProof::set_allocated_v(std::string* v) {
  if (v != nullptr) {
    
  } else {
    
  }
  v_.SetAllocated(v, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (v_.IsDefault()) {
    v_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailEncMulProof.v)
}

// -------------------------------------------------------------------

// PailMulGroupEleRangeProof

// string A = 1;
inline void PailMulGroupEleRangeProof::clear_a() {
  a_.ClearToEmpty();
}
inline const std::string& PailMulGroupEleRangeProof::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.A)
  return _internal_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailMulGroupEleRangeProof::set_a(ArgT0&& arg0, ArgT... args) {
 
 a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailMulGroupEleRangeProof.A)
}
inline std::string* PailMulGroupEleRangeProof::mutable_a() {
  std::string* _s = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.A)
  return _s;
}
inline const std::string& PailMulGroupEleRangeProof::_internal_a() const {
  return a_.Get();
}
inline void PailMulGroupEleRangeProof::_internal_set_a(const std::string& value) {
  
  a_.Set(value, GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::_internal_mutable_a() {
  
  return a_.Mutable(GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.A)
  return a_.Release();
}
inline void PailMulGroupEleRangeProof::set_allocated_a(std::string* a) {
  if (a != nullptr) {
    
  } else {
    
  }
  a_.SetAllocated(a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (a_.IsDefault()) {
    a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.A)
}

// .safeheron.proto.CurvePoint B = 2;
inline bool PailMulGroupEleRangeProof::_internal_has_b() const {
  return this != internal_default_instance() && b_ != nullptr;
}
inline bool PailMulGroupEleRangeProof::has_b() const {
  return _internal_has_b();
}
inline const ::safeheron::proto::CurvePoint& PailMulGroupEleRangeProof::_internal_b() const {
  const ::safeheron::proto::CurvePoint* p = b_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& PailMulGroupEleRangeProof::b() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.B)
  return _internal_b();
}
inline void PailMulGroupEleRangeProof::unsafe_arena_set_allocated_b(
    ::safeheron::proto::CurvePoint* b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(b_);
  }
  b_ = b;
  if (b) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.B)
}
inline ::safeheron::proto::CurvePoint* PailMulGroupEleRangeProof::release_b() {
  
  ::safeheron::proto::CurvePoint* temp = b_;
  b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailMulGroupEleRangeProof::unsafe_arena_release_b() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.B)
  
  ::safeheron::proto::CurvePoint* temp = b_;
  b_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* PailMulGroupEleRangeProof::_internal_mutable_b() {
  
  if (b_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    b_ = p;
  }
  return b_;
}
inline ::safeheron::proto::CurvePoint* PailMulGroupEleRangeProof::mutable_b() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.B)
  return _msg;
}
inline void PailMulGroupEleRangeProof::set_allocated_b(::safeheron::proto::CurvePoint* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(b_);
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(b));
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    
  } else {
    
  }
  b_ = b;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.B)
}

// string E = 3;
inline void PailMulGroupEleRangeProof::clear_e() {
  e_.ClearToEmpty();
}
inline const std::string& PailMulGroupEleRangeProof::e() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.E)
  return _internal_e();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailMulGroupEleRangeProof::set_e(ArgT0&& arg0, ArgT... args) {
 
 e_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailMulGroupEleRangeProof.E)
}
inline std::string* PailMulGroupEleRangeProof::mutable_e() {
  std::string* _s = _internal_mutable_e();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.E)
  return _s;
}
inline const std::string& PailMulGroupEleRangeProof::_internal_e() const {
  return e_.Get();
}
inline void PailMulGroupEleRangeProof::_internal_set_e(const std::string& value) {
  
  e_.Set(value, GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::_internal_mutable_e() {
  
  return e_.Mutable(GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::release_e() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.E)
  return e_.Release();
}
inline void PailMulGroupEleRangeProof::set_allocated_e(std::string* e) {
  if (e != nullptr) {
    
  } else {
    
  }
  e_.SetAllocated(e, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (e_.IsDefault()) {
    e_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.E)
}

// string S = 4;
inline void PailMulGroupEleRangeProof::clear_s() {
  s_.ClearToEmpty();
}
inline const std::string& PailMulGroupEleRangeProof::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.S)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailMulGroupEleRangeProof::set_s(ArgT0&& arg0, ArgT... args) {
 
 s_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailMulGroupEleRangeProof.S)
}
inline std::string* PailMulGroupEleRangeProof::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.S)
  return _s;
}
inline const std::string& PailMulGroupEleRangeProof::_internal_s() const {
  return s_.Get();
}
inline void PailMulGroupEleRangeProof::_internal_set_s(const std::string& value) {
  
  s_.Set(value, GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::_internal_mutable_s() {
  
  return s_.Mutable(GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.S)
  return s_.Release();
}
inline void PailMulGroupEleRangeProof::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    
  } else {
    
  }
  s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_.IsDefault()) {
    s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.S)
}

// string z1 = 5;
inline void PailMulGroupEleRangeProof::clear_z1() {
  z1_.ClearToEmpty();
}
inline const std::string& PailMulGroupEleRangeProof::z1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.z1)
  return _internal_z1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailMulGroupEleRangeProof::set_z1(ArgT0&& arg0, ArgT... args) {
 
 z1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailMulGroupEleRangeProof.z1)
}
inline std::string* PailMulGroupEleRangeProof::mutable_z1() {
  std::string* _s = _internal_mutable_z1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.z1)
  return _s;
}
inline const std::string& PailMulGroupEleRangeProof::_internal_z1() const {
  return z1_.Get();
}
inline void PailMulGroupEleRangeProof::_internal_set_z1(const std::string& value) {
  
  z1_.Set(value, GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::_internal_mutable_z1() {
  
  return z1_.Mutable(GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::release_z1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.z1)
  return z1_.Release();
}
inline void PailMulGroupEleRangeProof::set_allocated_z1(std::string* z1) {
  if (z1 != nullptr) {
    
  } else {
    
  }
  z1_.SetAllocated(z1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z1_.IsDefault()) {
    z1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.z1)
}

// string z2 = 6;
inline void PailMulGroupEleRangeProof::clear_z2() {
  z2_.ClearToEmpty();
}
inline const std::string& PailMulGroupEleRangeProof::z2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.z2)
  return _internal_z2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailMulGroupEleRangeProof::set_z2(ArgT0&& arg0, ArgT... args) {
 
 z2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailMulGroupEleRangeProof.z2)
}
inline std::string* PailMulGroupEleRangeProof::mutable_z2() {
  std::string* _s = _internal_mutable_z2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.z2)
  return _s;
}
inline const std::string& PailMulGroupEleRangeProof::_internal_z2() const {
  return z2_.Get();
}
inline void PailMulGroupEleRangeProof::_internal_set_z2(const std::string& value) {
  
  z2_.Set(value, GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::_internal_mutable_z2() {
  
  return z2_.Mutable(GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::release_z2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.z2)
  return z2_.Release();
}
inline void PailMulGroupEleRangeProof::set_allocated_z2(std::string* z2) {
  if (z2 != nullptr) {
    
  } else {
    
  }
  z2_.SetAllocated(z2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (z2_.IsDefault()) {
    z2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.z2)
}

// string w = 7;
inline void PailMulGroupEleRangeProof::clear_w() {
  w_.ClearToEmpty();
}
inline const std::string& PailMulGroupEleRangeProof::w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.PailMulGroupEleRangeProof.w)
  return _internal_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PailMulGroupEleRangeProof::set_w(ArgT0&& arg0, ArgT... args) {
 
 w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.PailMulGroupEleRangeProof.w)
}
inline std::string* PailMulGroupEleRangeProof::mutable_w() {
  std::string* _s = _internal_mutable_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.PailMulGroupEleRangeProof.w)
  return _s;
}
inline const std::string& PailMulGroupEleRangeProof::_internal_w() const {
  return w_.Get();
}
inline void PailMulGroupEleRangeProof::_internal_set_w(const std::string& value) {
  
  w_.Set(value, GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::_internal_mutable_w() {
  
  return w_.Mutable(GetArenaForAllocation());
}
inline std::string* PailMulGroupEleRangeProof::release_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.PailMulGroupEleRangeProof.w)
  return w_.Release();
}
inline void PailMulGroupEleRangeProof::set_allocated_w(std::string* w) {
  if (w != nullptr) {
    
  } else {
    
  }
  w_.SetAllocated(w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (w_.IsDefault()) {
    w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.PailMulGroupEleRangeProof.w)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_zkp_2eproto
